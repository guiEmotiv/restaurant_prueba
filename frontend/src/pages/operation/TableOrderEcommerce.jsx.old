import { useState, useEffect, useMemo, useCallback } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { useToast } from '../../contexts/ToastContext';
import { apiService } from '../../services/api';
import bluetoothPrinter from '../../services/bluetoothPrinter';

const TableOrderEcommerce = () => {
  const { user, userRole, hasPermission } = useAuth();
  const { showToast } = useToast();


  // Estados principales
  const [tables, setTables] = useState([]);
  const [selectedTable, setSelectedTable] = useState(null);
  const [allOrders, setAllOrders] = useState([]); 
  const [recipes, setRecipes] = useState([]);
  const [groups, setGroups] = useState([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [step, setStep] = useState('tables'); // 'tables', 'orders', 'menu', 'payment'
  
  // Estados para filtros de mesa
  const [selectedZoneFilter, setSelectedZoneFilter] = useState('todos');
  const [selectedStatusFilter, setSelectedStatusFilter] = useState('todos'); // 'todos', 'disponibles', 'ocupadas'

  // Estados carrito
  const [cart, setCart] = useState([]);
  const [selectedGroup, setSelectedGroup] = useState(null);
  const [currentOrder, setCurrentOrder] = useState(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [isCartOpen, setIsCartOpen] = useState(false);

  // Estados para modal de notas y para llevar
  const [isNoteModalOpen, setIsNoteModalOpen] = useState(false);
  const [selectedRecipe, setSelectedRecipe] = useState(null);
  const [noteText, setNoteText] = useState('');
  const [isTakeaway, setIsTakeaway] = useState(false);
  const [containers, setContainers] = useState([]);

  // Estados para paso de pago
  const [selectedOrderForPayment, setSelectedOrderForPayment] = useState(null);
  const [paymentProcessing, setPaymentProcessing] = useState(false);
  const [selectedItems, setSelectedItems] = useState([]); // Items seleccionados para pago
  const [paymentMethod, setPaymentMethod] = useState('CASH');
  const [paymentDescription, setPaymentDescription] = useState('');
  const [withPrinting, setWithPrinting] = useState(false);
  const [bluetoothConnected, setBluetoothConnected] = useState(false);
  const [connectingBluetooth, setConnectingBluetooth] = useState(false);

  // üé∞ Auto-update simple para vista de mesas (volvemos al sistema anterior)
  const TABLES_REFRESH_INTERVAL = 8000; // 8 segundos para vista de mesas

  useEffect(() => {
    loadInitialData();
    
    // Auto-update SOLO para vista de mesas
    if (step === 'tables') {
      const interval = setInterval(async () => {
        if (!document.hidden) {
          try {
            const allOrders = await apiService.orders.getAll();
            const activeOrders = allOrders?.filter(o => o.status === 'CREATED') || [];
            
            setAllOrders(activeOrders);
            
            if (import.meta.env.MODE === 'development') {
            }
          } catch (error) {
            if (import.meta.env.MODE === 'development') {
            }
          }
        }
      }, TABLES_REFRESH_INTERVAL);
      
      return () => clearInterval(interval);
    }
    
    if (import.meta.env.MODE === 'development') {
    }
  }, [step]);

  // Helper functions para gesti√≥n de pedidos
  
  // üöÄ OPTIMIZACI√ìN: getItemStatusColor con useCallback
  const getItemStatusColor = useCallback((status) => {
    switch (status) {
      case 'CREATED': return 'bg-green-500'; // Verde para creados
      case 'PREPARING': return 'bg-yellow-500'; // Amarillo para preparando
      case 'SERVED': return 'bg-blue-500'; // Azul para servidos
      case 'PAID': return 'bg-gray-500'; // Gris para pagados
      default: return 'bg-gray-400'; // Gris claro por defecto
    }
  }, []);

  // üöÄ OPTIMIZACI√ìN: getSelectedContainer con useCallback
  const getSelectedContainer = useCallback((recipe) => {
    if (!containers.length || !recipe?.container_id) return null;
    
    // Buscar EXCLUSIVAMENTE el envase configurado en la receta
    const recipeContainer = containers.find(c => c.id === recipe.container_id);
    
    // Solo retornarlo si existe y tiene stock - SIN FALLBACK
    return (recipeContainer && recipeContainer.stock > 0) ? recipeContainer : null;
  }, [containers]);

  // üöÄ OPTIMIZACI√ìN: validateTakeawayContainer con useCallback
  const validateTakeawayContainer = useCallback((recipe) => {
    if (!recipe?.container_id) {
      return {
        isValid: false,
        message: "Esta receta no tiene envase configurado para llevar"
      };
    }
    
    const recommendedContainer = containers.find(c => c.id === recipe.container_id);
    if (!recommendedContainer || recommendedContainer.stock <= 0) {
      return {
        isValid: false,
        message: `El envase "${containers.find(c => c.id === recipe.container_id)?.name || 'configurado'}" no tiene stock disponible`
      };
    }
    
    return { isValid: true, container: recommendedContainer };
  }, [containers]);
  // üöÄ OPTIMIZACI√ìN: checkOrderCurrentStatus con useCallback
  const checkOrderCurrentStatus = useCallback(async (orderId) => {
    try {
      const order = await apiService.orders.getById(orderId);
      return order;
    } catch (error) {
      if (import.meta.env.MODE === 'development') {
      }
      return null;
    }
  }, []);

  // üöÄ OPTIMIZACI√ìN: canDeleteOrder con useCallback
  const canDeleteOrder = useCallback((order) => {
    // Se puede eliminar si:
    // 1. El pedido est√° vac√≠o (sin items), O
    // 2. TODOS los items est√°n en estado CREATED
    if (!order.items || order.items.length === 0) return true;
    
    const createdItems = order.items.filter(item => item.status === 'CREATED');
    
    // Solo se puede eliminar si TODOS los items est√°n CREATED
    return createdItems.length === order.items.length;
  }, []);

  // üöÄ OPTIMIZACI√ìN: analyzeOrderDeletionStatus con useCallback
  const analyzeOrderDeletionStatus = useCallback((order) => {
    if (!order.items || order.items.length === 0) {
      return { canDelete: true, reason: '' };
    }

    const statusGroups = {
      CREATED: order.items.filter(item => item.status === 'CREATED'),
      PREPARING: order.items.filter(item => item.status === 'PREPARING'),
      SERVED: order.items.filter(item => item.status === 'SERVED'),
      PAID: order.items.filter(item => item.status === 'PAID')
    };

    const totalItems = order.items.length;
    
    if (statusGroups.CREATED.length === totalItems) {
      return { canDelete: true, reason: '' };
    }

    // Construir mensaje espec√≠fico
    let reasons = [];
    if (statusGroups.PREPARING.length > 0) {
      reasons.push(`${statusGroups.PREPARING.length} en preparaci√≥n`);
    }
    if (statusGroups.SERVED.length > 0) {
      reasons.push(`${statusGroups.SERVED.length} servido${statusGroups.SERVED.length > 1 ? 's' : ''}`);
    }
    if (statusGroups.PAID.length > 0) {
      reasons.push(`${statusGroups.PAID.length} pagado${statusGroups.PAID.length > 1 ? 's' : ''}`);
    }

    const reasonText = reasons.join(', ');
    return { 
      canDelete: false, 
      reason: `Tiene items ya procesados: ${reasonText}` 
    };
  }, []);

  // üöÄ OPTIMIZACI√ìN: canProcessPayment con useCallback
  const canProcessPayment = useCallback((order) => {
    if (!order || order.status === 'PAID' || !order.items || order.items.length === 0) {
      return false;
    }
    
    // Buscar items que est√©n SERVED y no pagados
    const servedUnpaidItems = order.items.filter(item => 
      item.status === 'SERVED' && !item.is_fully_paid
    );
    
    return servedUnpaidItems.length > 0;
  }, []);

  // Cargar datos iniciales
  const loadInitialData = useCallback(async () => {
    try {
      setLoading(true);
      const [tables, recipes, groups, allOrders, containers] = await Promise.all([
        apiService.tables.getAll(),
        apiService.recipes.getAll({ is_active: true, is_available: true }),
        apiService.groups.getAll(),
        apiService.orders.getAll(),
        apiService.containers.getAll()
      ]);
      
      setTables(tables || []);
      setRecipes(recipes || []);
      setGroups(groups || []);
      setContainers(containers || []);
      // Filtrar √≥rdenes activas en frontend para mayor control
      setAllOrders(allOrders?.filter(o => o.status === 'CREATED') || []);
    } catch (error) {
      showToast(`Error al cargar datos: ${error.message}`, 'error');
    } finally {
      setLoading(false);
    }
  }, [showToast]);

  // Cargar datos iniciales al montar componente
  useEffect(() => {
    loadInitialData();
  }, [loadInitialData]);

  // Computed property para √≥rdenes de la mesa actual
  const currentTableOrders = useMemo(() => {
    if (!selectedTable) return [];
    return allOrders.filter(order => {
      const orderTableId = order.table?.id || order.table || order.table_id;
      return orderTableId === selectedTable.id;
    });
  }, [allOrders, selectedTable]);

  // Sincronizaci√≥n simple de currentOrder (solo cuando cambia allOrders)
  useEffect(() => {
    if (currentOrder && allOrders.length > 0) {
      const updatedCurrentOrder = allOrders.find(order => order.id === currentOrder.id);
      if (updatedCurrentOrder && updatedCurrentOrder !== currentOrder) {
        setCurrentOrder(updatedCurrentOrder);
      }
    }
  }, [allOrders, currentOrder?.id]);

  // Cargar √≥rdenes de mesa espec√≠fica con items detallados (optimizado)
  const loadTableOrders = async (tableId) => {
    try {
      const orders = await apiService.tables.getActiveOrders(tableId);
      
      // Optimizaci√≥n: obtener IDs de √≥rdenes sin items para hacer una sola llamada
      const orderIdsNeedingItems = (orders || [])
        .filter(order => !order.items || order.items.length === 0)
        .map(order => order.id);
      
      if (orderIdsNeedingItems.length === 0) {
        // Si todas las √≥rdenes ya tienen items, usar las existentes
        setAllOrders(prevOrders => {
          const otherOrders = prevOrders.filter(order => {
            const orderTableId = order.table?.id || order.table || order.table_id;
            return orderTableId !== tableId;
          });
          return [...otherOrders, ...orders];
        });
        return;
      }

      // Cargar √≥rdenes detalladas en lote (reduce N+1 queries)
      const detailedOrdersPromises = orderIdsNeedingItems.map(orderId => 
        apiService.orders.getById(orderId).catch(error => {
          return orders.find(o => o.id === orderId); // Fallback a la orden original
        })
      );
      
      const detailedOrders = await Promise.all(detailedOrdersPromises);
      
      // Combinar √≥rdenes: las que ya ten√≠an items + las detalladas
      const ordersWithItems = orders.map(order => {
        if (!order.items || order.items.length === 0) {
          return detailedOrders.find(detailed => detailed.id === order.id) || order;
        }
        return order;
      });
      
      // Actualizar allOrders con las √≥rdenes detalladas de esta mesa
      setAllOrders(prevOrders => {
        const otherOrders = prevOrders.filter(order => {
          const orderTableId = order.table?.id || order.table || order.table_id;
          return orderTableId !== tableId;
        });
        return [...otherOrders, ...ordersWithItems];
      });
      
    } catch (error) {
      showToast(`Error al cargar pedidos de mesa: ${error.message}`, 'error');
    }
  };

  // Memoizaci√≥n optimizada: crear un Map de orders por table una sola vez
  const ordersByTable = useMemo(() => {
    const map = new Map();
    allOrders.forEach(order => {
      const orderTableId = order.table?.id || order.table || order.table_id;
      if (!map.has(orderTableId)) {
        map.set(orderTableId, []);
      }
      map.get(orderTableId).push(order);
    });
    return map;
  }, [allOrders]);

  // Obtener √≥rdenes de una mesa (ahora O(1) en lugar de O(n))
  const getTableOrders = useCallback((tableId) => {
    return ordersByTable.get(tableId) || [];
  }, [ordersByTable]);

  // Estado de mesa optimizado
  const getTableStatus = useCallback((tableId) => {
    const orders = ordersByTable.get(tableId) || [];
    return orders.length > 0 ? 'occupied' : 'available';
  }, [ordersByTable]);

  // Resumen de mesa optimizado con un solo reduce
  const getTableSummary = useCallback((tableId) => {
    const orders = getTableOrders(tableId);
    if (orders.length === 0) return null;
    
    const summary = orders.reduce((acc, order) => ({
      orderCount: acc.orderCount + 1,
      totalAmount: acc.totalAmount + parseFloat(order.grand_total || order.total_amount || 0),
      totalItems: acc.totalItems + (order.items?.length || 0)
    }), { orderCount: 0, totalAmount: 0, totalItems: 0 });
    
    return summary;
  }, [getTableOrders]);

  // Seleccionar mesa
  const handleTableSelect = async (table) => {
    setSelectedTable(table);
    await loadTableOrders(table.id);
    setStep('orders');
  };

  // üöÄ OPTIMIZACI√ìN: handleCreateNewOrder con useCallback
  const handleCreateNewOrder = useCallback(() => {
    setCart([]);
    setCurrentOrder(null);
    setIsCartOpen(false); // Cerrar carrito al crear nuevo pedido
    setStep('menu');
  }, []);

  // üöÄ OPTIMIZACI√ìN: handleEditOrder con useCallback
  const handleEditOrder = useCallback((order) => {
    setCurrentOrder(order);
    // CORRECCI√ìN: No pre-llenar carrito con items existentes
    // El carrito debe empezar vac√≠o para agregar NUEVOS items √∫nicamente
    setCart([]);
    // NO abrir autom√°ticamente - el usuario decide cu√°ndo ver la lista
    setIsCartOpen(false);
    setStep('menu');
  }, []);

  // üöÄ OPTIMIZACI√ìN: openNoteModal con useCallback y scroll lock
  const openNoteModal = useCallback((recipe) => {
    // üíæ Guardar scroll position ANTES de abrir modal
    const scrollY = window.scrollY;
    document.body.style.position = 'fixed';
    document.body.style.top = `-${scrollY}px`;
    document.body.style.width = '100%';
    document.body.setAttribute('data-scroll-locked', scrollY.toString());
    
    setSelectedRecipe(recipe);
    setNoteText('');
    setIsTakeaway(false);
    setIsNoteModalOpen(true);
  }, []);

  // üöÄ OPTIMIZACI√ìN: closeNoteModal con useCallback y unlock scroll
  const closeNoteModal = useCallback(() => {
    // üîì UNLOCK: Restaurar scroll position desde data attribute
    const scrollY = document.body.getAttribute('data-scroll-locked');
    
    // Limpiar estilos de scroll lock
    document.body.style.position = '';
    document.body.style.top = '';
    document.body.style.width = '';
    document.body.removeAttribute('data-scroll-locked');
    
    setIsNoteModalOpen(false);
    setSelectedRecipe(null);
    setNoteText('');
    setIsTakeaway(false);
    
    // Restaurar scroll position exacta
    if (scrollY) {
      window.scrollTo(0, parseInt(scrollY, 10));
    }
  }, []);

  // ‚úÖ Mensaje temporal de √©xito para items agregados
  const showSuccessMessage = useCallback((recipeName) => {
    showToast(`‚úÖ ${recipeName} agregado al pedido`, 'success', 1000);
  }, [showToast]);

  // üöÄ OPTIMIZACI√ìN: handleAddWithNotes con useCallback (scroll lock maneja la posici√≥n)
  const handleAddWithNotes = useCallback(() => {
    if (!selectedRecipe) return;
    
    const existingIndex = cart.findIndex(item => 
      item.recipe.id === selectedRecipe.id && 
      item.notes === noteText && 
      item.is_takeaway === isTakeaway
    );
    
    if (existingIndex >= 0) {
      const newCart = [...cart];
      newCart[existingIndex].quantity += 1;
      newCart[existingIndex].total_price = newCart[existingIndex].unit_price * newCart[existingIndex].quantity;
      setCart(newCart);
    } else {
      let basePrice = parseFloat(selectedRecipe.price || selectedRecipe.base_price || 0);
      let containerPrice = 0;
      
      // Validar si es para llevar - SOLO envase de receta permitido
      if (isTakeaway) {
        const validation = validateTakeawayContainer(selectedRecipe);
        if (!validation.isValid) {
          showToast(validation.message, 'error');
          return; // No agregar al carrito
        }
        // Si es v√°lido, usar el envase de la receta
        containerPrice = parseFloat(validation.container.price || 0);
      }
      
      const totalUnitPrice = basePrice + containerPrice;
      
      setCart([...cart, {
        recipe: selectedRecipe,
        quantity: 1,
        notes: noteText,
        is_takeaway: isTakeaway,
        unit_price: totalUnitPrice,
        total_price: totalUnitPrice,
        container_price: containerPrice
      }]);
    }
    
    // ‚úÖ Mostrar mensaje de √©xito
    showSuccessMessage(selectedRecipe.name);
    
    // üö´ Cerrar modal (scroll lock maneja la restauraci√≥n)
    closeNoteModal();
    
  }, [cart, selectedRecipe, noteText, isTakeaway, validateTakeawayContainer, showToast, closeNoteModal, showSuccessMessage]);

  // üöÄ OPTIMIZACI√ìN: addToCart con useCallback y mensaje de √©xito
  const addToCart = useCallback((recipe) => {
    const existingIndex = cart.findIndex(item => 
      item.recipe.id === recipe.id && 
      item.notes === '' && 
      item.is_takeaway === false
    );
    
    if (existingIndex >= 0) {
      const newCart = [...cart];
      newCart[existingIndex].quantity += 1;
      newCart[existingIndex].total_price = newCart[existingIndex].unit_price * newCart[existingIndex].quantity;
      setCart(newCart);
    } else {
      const price = parseFloat(recipe.price || recipe.base_price || 0);
      setCart([...cart, {
        recipe,
        quantity: 1,
        notes: '',
        is_takeaway: false,
        unit_price: price,
        total_price: price,
        container_price: 0
      }]);
    }
    
    // ‚úÖ Mostrar mensaje de √©xito
    showSuccessMessage(recipe.name);
    
    // No abrir autom√°ticamente - solo respuesta visual en el badge
  }, [cart, showSuccessMessage]);

  // üöÄ OPTIMIZACI√ìN: updateCartItem con useCallback y funci√≥n callback
  const updateCartItem = useCallback((index, field, value) => {
    setCart(prevCart => {
      const newCart = [...prevCart];
      newCart[index][field] = value;
      
      if (field === 'quantity') {
        newCart[index].total_price = newCart[index].unit_price * value;
      }
      
      return newCart;
    });
  }, []);

  // üöÄ OPTIMIZACI√ìN: removeFromCart con useCallback
  const removeFromCart = useCallback((index) => {
    setCart(prevCart => prevCart.filter((_, i) => i !== index));
  }, []);

  // üöÄ OPTIMIZACI√ìN: getCartTotal con useMemo
  const getCartTotal = useMemo(() => {
    return cart.reduce((total, item) => total + item.total_price, 0);
  }, [cart]);

  // üöÄ OPTIMIZACI√ìN: getCurrentOrderTotal con useMemo
  const getCurrentOrderTotal = useMemo(() => {
    if (!currentOrder) return 0;
    // Usar grand_total si existe, sino calcular manualmente
    const grandTotal = currentOrder.grand_total;
    if (grandTotal && grandTotal > 0) {
      return parseFloat(grandTotal);
    }
    // Fallback: sumar total_amount + containers_total
    const totalAmount = parseFloat(currentOrder.total_amount || 0);
    const containersTotal = parseFloat(currentOrder.containers_total || 0);
    return totalAmount + containersTotal;
  }, [currentOrder]);

  // üöÄ OPTIMIZACI√ìN: getCompleteTotal con useMemo
  const getCompleteTotal = useMemo(() => {
    return getCurrentOrderTotal + getCartTotal;
  }, [getCurrentOrderTotal, getCartTotal]);

  // Eliminar pedido completo con validaci√≥n en tiempo real
  const handleDeleteOrder = async (order) => {
    try {
      setSaving(true);
      
      // üîç VALIDACI√ìN EN TIEMPO REAL: Verificar estado actual completo de la orden
      if (import.meta.env.MODE === 'development') {
      }
      
      const currentOrder = await checkOrderCurrentStatus(order.id);
      
      if (!currentOrder) {
        showToast('Error al verificar el estado de la orden', 'error');
        return;
      }
      
      // Analizar estado actual y generar mensaje espec√≠fico
      const analysis = analyzeOrderDeletionStatus(currentOrder);
      
      if (!analysis.canDelete) {
        showToast(`No se puede eliminar el pedido #${order.id}: ${analysis.reason}`, 'error');
        return;
      }
      
      // Si llegamos aqu√≠, todos los items est√°n CREATED y se puede eliminar
      const confirmed = window.confirm(`¬øEst√°s seguro de eliminar el pedido #${order.id}?`);
      if (!confirmed) return;

      await apiService.orders.delete(order.id);
      showToast('Pedido eliminado correctamente', 'success');
      await loadTableOrders(selectedTable.id);
      
    } catch (error) {
      if (error.response?.status === 400 && error.response?.data?.error?.includes('status')) {
        showToast('No se puede eliminar: algunos items ya est√°n en proceso', 'error');
      } else {
        showToast('Error al eliminar pedido', 'error');
      }
    } finally {
      setSaving(false);
    }
  };

  // Procesar pago del pedido - Navegar a paso de pago
  const handleProcessPayment = (order) => {
    // Solo verificar que hay items SERVED para pago individual
    const servedItems = order.items.filter(item => item.status === 'SERVED');
    if (servedItems.length === 0) {
      showToast('No hay items listos para pago', 'error');
      return;
    }
    
    setSelectedOrderForPayment(order);
    // Resetear estados de pago
    setSelectedItems([]);
    setPaymentMethod('CASH');
    setPaymentDescription('');
    setWithPrinting(false);
    setBluetoothConnected(false);
    setConnectingBluetooth(false);
    setStep('payment');
  };

  // Manejar selecci√≥n/deselecci√≥n de items
  // üöÄ OPTIMIZACI√ìN: handleItemSelection con useCallback
  const handleItemSelection = useCallback((itemId) => {
    // Verificar que el item est√© en estado SERVED y no est√© ya pagado
    const item = selectedOrderForPayment.items.find(i => i.id === itemId);
    if (!item || item.status !== 'SERVED' || item.is_fully_paid) {
      showToast('Este item no est√° disponible para pago', 'error');
      return;
    }

    setSelectedItems(prev => {
      if (prev.includes(itemId)) {
        return prev.filter(id => id !== itemId);
      } else {
        return [...prev, itemId];
      }
    });
  }, [selectedOrderForPayment, showToast]);

  // üöÄ OPTIMIZACI√ìN: Seleccionar/deseleccionar todos los items SERVED con useCallback
  const handleSelectAllServedItems = useCallback(() => {
    const servedItems = selectedOrderForPayment.items.filter(item => 
      item.status === 'SERVED' && !item.is_fully_paid
    );
    const allServedSelected = servedItems.every(item => selectedItems.includes(item.id));
    
    if (allServedSelected) {
      // Deseleccionar todos los SERVED
      setSelectedItems(prev => prev.filter(id => !servedItems.map(item => item.id).includes(id)));
    } else {
      // Seleccionar todos los SERVED no pagados
      const servedIds = servedItems.map(item => item.id);
      setSelectedItems(prev => [...new Set([...prev, ...servedIds])]);
    }
  }, [selectedOrderForPayment, selectedItems]);

  // üöÄ OPTIMIZACI√ìN: Manejar conexi√≥n/desconexi√≥n Bluetooth con useCallback
  const handleBluetoothToggle = useCallback(async (enabled) => {
    if (enabled) {
      setConnectingBluetooth(true);
      try {
        if (!bluetoothPrinter.isBluetoothSupported()) {
          showToast(bluetoothPrinter.getBluetoothErrorMessage(), 'error');
          setWithPrinting(false);
          return;
        }

        await bluetoothPrinter.connect();
        setBluetoothConnected(true);
        showToast('Impresora Bluetooth conectada exitosamente', 'success');
      } catch (error) {
        setBluetoothConnected(false);
        setWithPrinting(false);
        showToast(`Error conectando impresora: ${error.message}`, 'error');
      } finally {
        setConnectingBluetooth(false);
      }
    } else {
      bluetoothPrinter.disconnect();
      setBluetoothConnected(false);
      showToast('Impresora Bluetooth desconectada', 'info');
    }
  }, [bluetoothPrinter, showToast]);

  // üöÄ OPTIMIZACI√ìN: Verificar si todos los items est√°n pagados con useCallback
  const areAllItemsPaid = useCallback((order) => {
    if (!order.items || order.items.length === 0) return false;
    return order.items.every(item => item.status === 'PAID' || item.is_fully_paid);
  }, []);

  // üöÄ OPTIMIZACI√ìN: Imprimir comprobante para items seleccionados con useCallback
  const printSelectedItemsReceipt = useCallback(async (paidItems) => {
    try {
      if (!bluetoothConnected) {
        await bluetoothPrinter.connect();
      }

      const receiptData = {
        order: {
          id: selectedOrderForPayment.id,
          table_number: selectedTable?.table_number,
          waiter: user?.username || user?.email || 'Usuario',
          created_at: selectedOrderForPayment.created_at,
          items: paidItems.map(item => ({
            recipe_name: item.recipe_name,
            quantity: item.quantity,
            total_price: parseFloat(item.total_with_container || item.total_price || 0).toFixed(2),
            is_takeaway: item.is_takeaway
          }))
        },
        payment: {
          created_at: new Date().toISOString()
        },
        amount: paidItems.reduce((sum, item) => sum + parseFloat(item.total_with_container || item.total_price || 0), 0)
      };

      await bluetoothPrinter.printPaymentReceipt(receiptData);
      showToast('Comprobante impreso exitosamente', 'success');
    } catch (error) {
      showToast(`Error al imprimir: ${error.message}`, 'error');
    }
  }, [bluetoothConnected, selectedOrderForPayment, selectedTable, user, bluetoothPrinter, showToast]);

  // üöÄ OPTIMIZACI√ìN: Imprimir comprobante completo del pedido con useCallback
  const printFullReceipt = useCallback(async () => {
    try {
      if (!bluetoothPrinter.isBluetoothSupported()) {
        showToast(bluetoothPrinter.getBluetoothErrorMessage(), 'error');
        return;
      }

      if (!bluetoothConnected) {
        await bluetoothPrinter.connect();
        setBluetoothConnected(true);
      }

      const allItems = selectedOrderForPayment.items;
      const receiptData = {
        order: {
          id: selectedOrderForPayment.id,
          table_number: selectedTable?.table_number,
          waiter: user?.username || user?.email || 'Usuario',
          created_at: selectedOrderForPayment.created_at,
          total_amount: selectedOrderForPayment.total_amount,
          items: allItems.map(item => ({
            recipe_name: item.recipe_name,
            quantity: item.quantity,
            total_price: parseFloat(item.total_with_container || item.total_price || 0).toFixed(2),
            is_takeaway: item.is_takeaway
          }))
        },
        payment: {
          created_at: new Date().toISOString()
        },
        amount: allItems.reduce((sum, item) => sum + parseFloat(item.total_with_container || item.total_price || 0), 0)
      };

      await bluetoothPrinter.printPaymentReceipt(receiptData);
      showToast('Comprobante completo impreso exitosamente', 'success');
    } catch (error) {
      showToast(`Error al imprimir comprobante completo: ${error.message}`, 'error');
    }
  }, [bluetoothConnected, selectedOrderForPayment, selectedTable, user, bluetoothPrinter, showToast]);

  // üöÄ OPTIMIZACI√ìN: Procesar pago de items seleccionados con useCallback
  const handleProcessSelectedPayment = useCallback(async () => {
    if (selectedItems.length === 0) {
      showToast('Debe seleccionar al menos un item para pagar', 'error');
      return;
    }

    // Validar que todos los items seleccionados sean v√°lidos
    const invalidItems = selectedItems.filter(itemId => {
      const item = selectedOrderForPayment.items.find(i => i.id === itemId);
      return !item || item.status !== 'SERVED' || item.is_fully_paid;
    });

    if (invalidItems.length > 0) {
      showToast('Algunos items seleccionados no est√°n disponibles para pago', 'error');
      return;
    }

    setPaymentProcessing(true);
    try {
      const paymentData = {
        payment_method: paymentMethod,
        payer_name: user?.username || user?.email || 'Usuario',
        notes: paymentDescription
      };

      // Procesar pago para cada item seleccionado secuencialmente para mejor manejo de errores
      const results = [];
      for (const itemId of selectedItems) {
        try {
          const result = await apiService.orderItems.processPayment(itemId, paymentData);
          results.push(result);
        } catch (itemError) {
          throw new Error(`Error en item ${itemId}: ${itemError.response?.data?.error || itemError.message}`);
        }
      }
      
      showToast(`Pago procesado exitosamente para ${selectedItems.length} item(s)`, 'success');
      
      // ACTUALIZACI√ìN INMEDIATA - Forzar cambio visual antes de recargar backend
      const currentSelectedItems = [...selectedItems]; // Capturar los IDs antes de resetear
      
      setSelectedOrderForPayment(prevOrder => ({
        ...prevOrder,
        items: prevOrder.items.map(item => 
          currentSelectedItems.includes(item.id) 
            ? { ...item, status: 'PAID', is_fully_paid: true, paid_at: new Date().toISOString() }
            : item
        )
      }));
      
      // Resetear selecci√≥n inmediatamente para limpiar los filtros
      setSelectedItems([]);
      
      // Si se seleccion√≥ impresi√≥n, imprimir comprobante
      if (withPrinting && bluetoothConnected) {
        try {
          // Obtener los items que se acaban de pagar
          const paidItems = selectedOrderForPayment.items.filter(item => 
            currentSelectedItems.includes(item.id)
          );
          await printSelectedItemsReceipt(paidItems);
        } catch (printError) {
          showToast(`Error al imprimir: ${printError.message}`, 'error');
        }
      }
      
      // Recargar √≥rdenes para reflejar cambios en el backend
      await loadTableOrders(selectedTable.id);
      
      // Actualizar la orden seleccionada para pago con los datos m√°s recientes
      const updatedOrders = allOrders.filter(order => order.table === selectedTable.id);
      const updatedSelectedOrder = updatedOrders.find(order => order.id === selectedOrderForPayment.id);
      
      if (updatedSelectedOrder) {
        // Asegurar que los items pagados est√©n marcados correctamente
        const finalOrder = {
          ...updatedSelectedOrder,
          items: updatedSelectedOrder.items.map(item => 
            currentSelectedItems.includes(item.id) 
              ? { ...item, status: 'PAID', is_fully_paid: true, paid_at: item.paid_at || new Date().toISOString() }
              : item
          )
        };
        setSelectedOrderForPayment(finalOrder);
      } else {
        // Fallback: actualizar inmediatamente el estado local si no se encuentra la orden actualizada
        setSelectedOrderForPayment(prevOrder => ({
          ...prevOrder,
          items: prevOrder.items.map(item => 
            currentSelectedItems.includes(item.id) 
              ? { ...item, status: 'PAID', is_fully_paid: true, paid_at: new Date().toISOString() }
              : item
          )
        }));
      }
      
      // Resetear descripci√≥n
      setPaymentDescription('');
      
      return true;
    } catch (error) {
      
      // Manejo detallado de errores
      let errorMessage = 'Error desconocido al procesar pago';
      
      if (error.response) {
        // Error de respuesta del servidor
        const status = error.response.status;
        const data = error.response.data;
        
        if (status === 400) {
          errorMessage = data.error || data.message || 'Datos inv√°lidos para el pago';
        } else if (status === 404) {
          errorMessage = 'Item no encontrado';
        } else if (status === 500) {
          errorMessage = 'Error interno del servidor';
        } else {
          errorMessage = data.error || data.message || `Error del servidor (${status})`;
        }
      } else if (error.request) {
        // Error de red
        errorMessage = 'Error de conexi√≥n con el servidor';
      } else {
        // Error de configuraci√≥n
        errorMessage = error.message || 'Error de configuraci√≥n';
      }
      
      showToast(`Error al procesar pago: ${errorMessage}`, 'error');
      return false;
    } finally {
      setPaymentProcessing(false);
    }
  }, [selectedItems, selectedOrderForPayment, paymentMethod, paymentDescription, user, withPrinting, bluetoothConnected, printSelectedItemsReceipt, loadTableOrders, selectedTable, allOrders, showToast, apiService]);



  // Funci√≥n unificada de mapeo de items del carrito
  const mapCartItemToOrderData = (item) => {
    
    const data = {
      recipe: item.recipe.id,
      quantity: item.quantity,
      notes: item.notes || '',
      is_takeaway: item.is_takeaway || false,
      has_taper: item.is_takeaway || false
    };
    
    // Si es para llevar, usar el envase de la receta (validaci√≥n ya hecha)
    if (item.is_takeaway && containers.length > 0) {
      const recipe = recipes.find(r => r.id === item.recipe.id);
      
      // Para pedidos para llevar, SOLO usar el envase configurado en la receta
      if (recipe?.container_id) {
        const recipeContainer = containers.find(c => c.id === recipe.container_id);
        
        if (recipeContainer && recipeContainer.stock > 0) {
          data.selected_container = recipeContainer.id;
        }
      }
    }
    
    return data;
  };

  // Manejo especializado de errores
  const handleSaveOrderError = useCallback((error) => {
    if (error.response?.status === 400) {
      const errorDetails = error.response.data;
      
      // Primero verificar si hay un array de items con problemas
      if (errorDetails.items && Array.isArray(errorDetails.items)) {
        // Procesar cada item con problemas
        const problemItems = errorDetails.items.map(item => {
          // Buscar el nombre de la receta en diferentes posibles campos
          let recipeName = item.recipe_name || item.name;
          let errorMsg = item.error || item.message;
          
          // Si recipe es un array, puede contener el mensaje de error o datos de receta
          if (item.recipe && Array.isArray(item.recipe) && item.recipe.length > 0) {
            const recipeData = item.recipe[0];
            
            // Si el primer elemento es un string, es el mensaje de error
            if (typeof recipeData === 'string') {
              errorMsg = recipeData; // "No hay suficiente stock para esta receta"
            } else if (typeof recipeData === 'object') {
              // Si es un objeto, buscar el nombre
              recipeName = recipeData.name || recipeData.recipe_name || recipeData.id;
            }
          } else if (item.recipe && typeof item.recipe === 'object') {
            // Si recipe es un objeto directo
            recipeName = item.recipe.name || item.recipe.recipe_name;
          }
          
          if (recipeName) {
            return recipeName;
          } else if (errorMsg && errorMsg.includes('stock')) {
            // Si tenemos mensaje de error pero no nombre, intentar extraer de carrito
            // Para m√∫ltiples items, no duplicar, solo marcar como problem√°tico
            return 'item-with-stock-issue'; // Marcador temporal para procesar despu√©s
          } else {
            // Si no encontramos nombre, buscar en el carrito por ID si existe
            if (item.recipe_id || (item.recipe && Array.isArray(item.recipe) && item.recipe[0]?.id)) {
              const searchId = item.recipe_id || item.recipe[0]?.id;
              const cartItem = cart.find(c => c.recipe.id === searchId);
              if (cartItem) {
                return cartItem.recipe.name;
              }
            }
            return 'Item desconocido';
          }
        });
        
        // Procesar los marcadores de items con problemas de stock
        const stockIssueCount = problemItems.filter(item => item === 'item-with-stock-issue').length;
        const namedItems = problemItems.filter(item => item !== 'item-with-stock-issue');
        
        let finalMessage = '';
        
        if (stockIssueCount > 0 && namedItems.length === 0) {
          // Solo items sin nombre, usar lista del carrito
          const cartNames = cart.map(c => c.recipe.name).join(', ');
          finalMessage = `Sin stock de ingredientes. Items: ${cartNames}`;
        } else if (namedItems.length > 0 && stockIssueCount === 0) {
          // Solo items con nombre
          if (namedItems.length === 1) {
            finalMessage = `Sin stock: "${namedItems[0]}" no tiene ingredientes suficientes`;
          } else {
            finalMessage = `Sin stock para: ${namedItems.join(', ')}`;
          }
        } else {
          // Mezcla de items con y sin nombre
          const allNames = [...namedItems];
          if (stockIssueCount > 0) {
            const cartNames = cart.map(c => c.recipe.name);
            // Agregar solo los que no est√°n ya en namedItems
            cartNames.forEach(name => {
              if (!allNames.includes(name)) {
                allNames.push(name);
              }
            });
          }
          finalMessage = `Sin stock para: ${allNames.join(', ')}`;
        }
        
        showToast(finalMessage, 'error');
        return; // Salir temprano para no procesar otros casos
      }
      
      // Verificar si el error es por falta de stock
      const errorMessage = errorDetails.error || errorDetails.message || '';
      const errorMessageLower = errorMessage.toLowerCase();
      
      if (errorMessageLower.includes('stock') || errorMessageLower.includes('ingrediente')) {
        // Intentar identificar qu√© recetas tienen problema
        if (errorDetails.details?.recipe_name) {
          showToast(`Sin stock: "${errorDetails.details.recipe_name}" no tiene ingredientes suficientes`, 'error');
        } else if (errorDetails.details?.items) {
          // Si hay m√∫ltiples items con problemas
          const itemsWithIssues = errorDetails.details.items.join(', ');
          showToast(`Sin stock para: ${itemsWithIssues}`, 'error');
        } else if (errorDetails.recipe_name) {
          // A veces el nombre viene directamente
          showToast(`Sin stock: "${errorDetails.recipe_name}" no tiene ingredientes suficientes`, 'error');
        } else {
          // Buscar en el carrito cu√°les podr√≠an ser los problem√°ticos
          const cartRecipeNames = cart.map(item => item.recipe.name).join(', ');
          showToast(`Sin stock de ingredientes. Items en carrito: ${cartRecipeNames}`, 'error');
        }
      } else if (errorDetails.details?.recipe) {
        showToast('Receta no v√°lida o no disponible', 'error');
      } else if (errorDetails.details?.quantity) {
        showToast('Cantidad no v√°lida', 'error');
      } else if (errorMessage) {
        // Si hay un mensaje de error espec√≠fico, mostrarlo
        showToast(errorMessage, 'error');
      } else {
        showToast('Error al procesar el pedido', 'error');
      }
    } else if (error.response?.status === 404) {
      showToast('Pedido no encontrado', 'error');
    } else if (error.response?.status === 422) {
      // 422 generalmente indica problemas de validaci√≥n o stock
      const errorData = error.response.data;
      const errorMsg = errorData?.error || errorData?.message || '';
      const errorDetails = errorData?.details;
      
      // Siempre asumir que 422 es problema de stock para recetas
      if (errorDetails?.recipe_name || errorData?.recipe_name) {
        const recipeName = errorDetails?.recipe_name || errorData?.recipe_name;
        showToast(`Sin stock: "${recipeName}" no tiene ingredientes suficientes`, 'error');
      } else if (errorDetails?.ingredient_name) {
        showToast(`Sin stock del ingrediente: ${errorDetails.ingredient_name}`, 'error');
      } else {
        // Listar items del carrito para ayudar al usuario
        const cartRecipeNames = cart.map(item => `${item.recipe.name} (x${item.quantity})`).join(', ');
        showToast(`Sin stock de ingredientes. Items en carrito: ${cartRecipeNames}`, 'error');
      }
    } else {
      showToast('Error al guardar pedido. Intente nuevamente.', 'error');
    }
  }, [cart, showToast]);

  // üöÄ OPTIMIZACI√ìN: Guardar pedido optimizado con useCallback
  const saveOrder = useCallback(async () => {
    if (cart.length === 0) {
      showToast('Agregue items al pedido', 'error');
      return;
    }

    try {
      setSaving(true);
      
      if (currentOrder) {
        // Para √≥rdenes existentes: usar add_item
        for (const item of cart) {
          const newItem = await apiService.orders.addItem(currentOrder.id, mapCartItemToOrderData(item));
          
          // Log de item creado (solo en desarrollo)
          if (import.meta.env.MODE === 'development') {
          }
        }
        showToast('Items agregados al pedido', 'success');
      } else {
        // Para √≥rdenes nuevas
        const newOrderData = {
          table: selectedTable.id,
          waiter: user?.username || 'Sistema',
          items: cart.map(mapCartItemToOrderData)
        };
        const newOrder = await apiService.orders.create(newOrderData);
        
        // Log de nuevo pedido creado (solo en desarrollo)
        if (import.meta.env.MODE === 'development') {
        }
        
        // Actualizar estado local eficientemente
        setAllOrders([...allOrders, newOrder]);
        showToast('Pedido creado', 'success');
      }

      // Recarga necesaria despu√©s de guardar
      await loadTableOrders(selectedTable.id);
      
      setCart([]);
      setCurrentOrder(null);
      setIsCartOpen(false); // Cerrar carrito despu√©s de guardar
      setStep('orders');
    } catch (error) {
      handleSaveOrderError(error);
    } finally {
      setSaving(false);
    }
  }, [cart, currentOrder, selectedTable, user, mapCartItemToOrderData, allOrders, loadTableOrders, handleSaveOrderError, showToast, apiService]);

  // Filtrar recetas
  const filteredRecipes = useMemo(() => {
    let filtered = recipes;
    
    if (selectedGroup) {
      filtered = filtered.filter(r => r.group?.id === selectedGroup);
    }
    
    if (searchTerm) {
      filtered = filtered.filter(r => 
        r.name.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    return filtered;
  }, [recipes, selectedGroup, searchTerm]);

  // üöÄ OPTIMIZACI√ìN: Contar recetas por grupo usando reduce para mejor performance
  const recipeCountByGroup = useMemo(() => {
    return recipes.reduce((counts, recipe) => {
      const groupId = recipe.group?.id || 'sin_grupo';
      counts[groupId] = (counts[groupId] || 0) + 1;
      return counts;
    }, {});
  }, [recipes]);

  // üöÄ OPTIMIZACI√ìN: Agrupar mesas por zona usando reduce para mejor performance
  const tablesByZone = useMemo(() => {
    return tables.reduce((zones, table) => {
      const zoneName = table.zone?.name || table.zone_name || 'Sin Zona';
      if (!zones[zoneName]) zones[zoneName] = [];
      zones[zoneName].push(table);
      return zones;
    }, {});
  }, [tables]);

  // Crear un Map de estados de mesa para evitar rec√°lculo en filtros
  const tableStatuses = useMemo(() => {
    const statusMap = new Map();
    tables.forEach(table => {
      const orders = ordersByTable.get(table.id) || [];
      statusMap.set(table.id, orders.length > 0 ? 'occupied' : 'available');
    });
    return statusMap;
  }, [tables, ordersByTable]);

  // Mesas filtradas por zona y estado (optimizado)
  const filteredTablesByZone = useMemo(() => {
    let filtered = { ...tablesByZone };
    
    // Filtro por zona (m√°s eficiente)
    if (selectedZoneFilter !== 'todos') {
      const zoneData = filtered[selectedZoneFilter];
      filtered = zoneData ? { [selectedZoneFilter]: zoneData } : {};
    }
    
    // Filtro por estado de mesa (usando el Map precomputado)
    if (selectedStatusFilter !== 'todos') {
      const filteredEntries = Object.entries(filtered).map(([zoneName, zoneTables]) => {
        const filteredTables = zoneTables.filter(table => {
          const status = tableStatuses.get(table.id);
          return selectedStatusFilter === 'disponibles' ? status === 'available' : status === 'occupied';
        });
        return [zoneName, filteredTables];
      }).filter(([, tables]) => tables.length > 0); // Eliminar zonas vac√≠as
      
      filtered = Object.fromEntries(filteredEntries);
    }
    
    return filtered;
  }, [tablesByZone, selectedZoneFilter, selectedStatusFilter, tableStatuses]);

  // Lista de zonas disponibles para el filtro
  const availableZones = useMemo(() => {
    return Object.keys(tablesByZone);
  }, [tablesByZone]);

  // Funci√≥n simple para actualizar cuando sea necesario
  const refreshCurrentData = useCallback(async () => {
    try {
      if (selectedTable && (step === 'orders' || step === 'menu' || step === 'payment')) {
        await loadTableOrders(selectedTable.id);
      }
    } catch (error) {
      if (import.meta.env.MODE === 'development') {
      }
    }
  }, [step, selectedTable, loadTableOrders]);
  
  // Funci√≥n para alternar carrito
  const toggleCart = useCallback(() => {
    setIsCartOpen(prev => !prev);
  }, []);

  // üöÄ OPTIMIZACI√ìN: Verificar estado actual del item en tiempo real antes de eliminar con useCallback
  const checkItemCurrentStatus = useCallback(async (itemId) => {
    try {
      const item = await apiService.orderItems.getById(itemId);
      return item.status;
    } catch (error) {
      return null;
    }
  }, [apiService]);

  // Helper para verificar si un item se puede eliminar (validaci√≥n local)
  const canDeleteItem = useCallback((item) => {
    // Solo se puede eliminar si est√° en estado CREATED
    return item.status === 'CREATED';
  }, []);

  // üöÄ OPTIMIZACI√ìN: Eliminar item individual del pedido existente con validaci√≥n en tiempo real con useCallback
  const handleDeleteOrderItem = useCallback(async (itemId) => {
    if (!currentOrder) return;

    try {
      setSaving(true);
      
      // üîç VALIDACI√ìN EN TIEMPO REAL: Verificar estado actual del item
      if (import.meta.env.MODE === 'development') {
      }
      
      const currentStatus = await checkItemCurrentStatus(itemId);
      
      if (currentStatus === null) {
        showToast('Error al verificar el estado del item', 'error');
        return;
      }
      
      if (currentStatus !== 'CREATED') {
        const statusLabels = {
          'PREPARING': 'en preparaci√≥n',
          'SERVED': 'servido',
          'PAID': 'pagado'
        };
        
        showToast(
          `No se puede eliminar: el item ya est√° ${statusLabels[currentStatus] || 'procesado'}`, 
          'error'
        );
        return;
      }
      
      // Si llegamos aqu√≠, el item est√° CREATED y se puede eliminar
      const confirmed = window.confirm('¬øEliminar este item del pedido?');
      if (!confirmed) return;

      await apiService.orderItems.delete(itemId);
      
      // Recargar el pedido actual para actualizar la lista
      const updatedOrder = await apiService.orders.getById(currentOrder.id);
      setCurrentOrder(updatedOrder);
      
      // Actualizar despu√©s de eliminar item
      await loadTableOrders(selectedTable.id);
      
      showToast('Item eliminado del pedido', 'success');
      
    } catch (error) {
      if (error.response?.status === 400 && error.response?.data?.error?.includes('status')) {
        showToast('No se puede eliminar: el item ya est√° en proceso', 'error');
      } else {
        showToast('Error al eliminar item', 'error');
      }
    } finally {
      setSaving(false);
    }
  }, [currentOrder, checkItemCurrentStatus, selectedTable, loadTableOrders, showToast, apiService]);

  // TODOS los hooks deben estar antes de este return condicional
  if (loading && step === 'tables') {
    return <div className="flex justify-center items-center h-screen">Cargando...</div>;
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header responsive mejorado con breadcrumbs - Oculto en vista de mesas */}
      {step !== 'tables' && (
      <div 
        className={`bg-white shadow-sm transition-transform duration-300 sticky top-0 z-[60] ${isCartOpen ? '-translate-y-full' : 'translate-y-0'}`}
        data-header-fixed
      >
        <div className="px-3 sm:px-4 py-3">
          {/* Breadcrumb */}
          <div className="flex items-center gap-2 text-sm text-gray-600 mb-2">
            <span className={step === 'tables' ? 'text-blue-600 font-medium' : ''}>
              Mesas
            </span>
            {step !== 'tables' && (
              <>
                <span>‚Üí</span>
                <span className={step === 'orders' ? 'text-blue-600 font-medium' : ''}>
                  Mesa {selectedTable?.table_number}
                </span>
              </>
            )}
            {step === 'menu' && (
              <>
                <span>‚Üí</span>
                <span className="text-blue-600 font-medium">
                  {currentOrder ? 'Agregar items' : 'Nuevo pedido'}
                </span>
              </>
            )}
            {step === 'payment' && (
              <>
                <span>‚Üí</span>
                <span className="text-blue-600 font-medium">
                  Procesar Pago
                </span>
              </>
            )}
          </div>
          
          <div className="flex items-center justify-between">
            {/* T√≠tulo a la izquierda */}
            <h1 className="text-base sm:text-lg font-bold truncate flex-1">
              {step === 'tables' && 'Seleccionar Mesa'}
              {step === 'orders' && 'Lista de Pedidos'}
              {step === 'menu' && (currentOrder ? `Pedido #${currentOrder.id}` : 'Nuevo Pedido')}
              {step === 'payment' && `Pagar Pedido #${selectedOrderForPayment?.id}`}
            </h1>
            
            {/* Bot√≥n Atr√°s en el centro */}
            {step !== 'tables' && (
              <div className="flex-1 flex justify-center">
                <button
                  onClick={() => {
                    if (step === 'menu') {
                      setStep('orders');
                    } else if (step === 'payment') {
                      setStep('orders');
                      setSelectedOrderForPayment(null);
                      setSelectedItems([]);
                      setPaymentMethod('CASH');
                      setPaymentDescription('');
                      setWithPrinting(false);
                    } else {
                      setStep('tables');
                    }
                  }}
                  className="text-blue-600 hover:text-blue-700 flex items-center gap-1 text-sm font-medium px-4 py-2 rounded-lg hover:bg-blue-50 transition-colors"
                >
                  ‚Üê Atr√°s
                </button>
              </div>
            )}
            
            {/* Carrito en el header (solo en vista menu) */}
            {step === 'menu' ? (
              <div className="flex-1 flex justify-end">
                <button
                  onClick={toggleCart}
                  className={`relative p-2 rounded-lg transition-all duration-300 ${
                    cart.length > 0 || currentOrder
                      ? 'text-blue-600 hover:text-blue-700 hover:bg-blue-50' 
                      : 'text-gray-400 hover:text-gray-500 hover:bg-gray-50'
                  }`}
                  title="Ver pedido"
                >
                  {/* Icono de comanda/nota de pedido m√°s grande */}
                  <svg className="w-9 h-9" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                  </svg>
                  
                  {/* Badge con cantidad total */}
                  {(() => {
                    const cartCount = cart.reduce((total, item) => total + item.quantity, 0);
                    const orderCount = currentOrder?.items?.length || 0;
                    const totalCount = cartCount + orderCount;
                    
                    return totalCount > 0 && (
                      <div className="absolute -top-1 -right-1 bg-red-500 text-white text-xs font-bold rounded-full h-5 w-5 flex items-center justify-center">
                        {totalCount}
                      </div>
                    );
                  })()} 
                </button>
              </div>
            ) : (
              <div className="flex-1"></div>
            )}
          </div>
        </div>
      </div>
      )}

      <div className={step === 'tables' ? 'p-0' : 'p-3 sm:p-4 pb-20'}>
        {/* VISTA MESAS - Con header fijo y agrupaci√≥n por zonas */}
        {step === 'tables' && (
          <div className="fixed inset-0 flex flex-col">
            {/* Header fijo */}
            <div className="bg-white border-b border-gray-200 p-3 flex-shrink-0">
              <h1 className="text-lg font-bold text-gray-900 text-center">Seleccionar Mesa</h1>
            </div>
            
            {/* Contenido con scroll */}
            <div className="flex-1 p-1 overflow-y-auto">
              {availableZones.length === 0 ? (
                <div className="text-center py-8 text-gray-500">
                  No hay mesas disponibles
                </div>
              ) : (
                availableZones.map(zoneName => {
                  const zoneTables = tables.filter(table => table.zone === zoneName);
                  return (
                    <div key={zoneName} className="mb-4">
                      <h2 className="text-sm font-semibold text-gray-700 mb-2 px-1">{zoneName}</h2>
                      <div className="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10 2xl:grid-cols-12 gap-1">
                        {zoneTables.map(table => {
                          const status = getTableStatus(table.id);
                          const summary = getTableSummary(table.id);
                          
                          const getTableButtonStyle = () => {
                            if (status === 'available' || !summary || summary.orderCount === 0) {
                              return 'bg-green-50 border-green-300 hover:bg-green-100';
                            } else {
                              return 'bg-orange-50 border-orange-300 hover:bg-orange-100';
                            }
                          };
                          
                          return (
                            <button
                              key={table.id}
                              onClick={() => handleTableSelect(table)}
                              className={`p-2 rounded border text-center transition-all duration-200 hover:scale-[1.02] ${getTableButtonStyle()}`}
                            >
                              <div className="font-bold text-sm">{table.table_number}</div>
                              {status === 'occupied' && summary && (
                                <div className="text-xs text-gray-600 mt-0.5">
                                  {summary.orderCount} ped.
                                </div>
                              )}
                            </button>
                          );
                        })}
                      </div>
                    </div>
                  );
                })
              )}
            </div>
          </div>
        )}

        {/* VISTA √ìRDENES */}
        {step === 'orders' && selectedTable && (
          <div className="space-y-4">
            {currentTableOrders.length === 0 ? (
              <div className="text-center py-8 text-gray-500">
                No hay pedidos activos
              </div>
            ) : (
              <div className="space-y-2">
                {currentTableOrders.map(order => (
                  <div key={order.id} className="bg-white border rounded p-3">
                    <div className="flex justify-between items-center mb-2">
                      <div className="flex items-center space-x-3">
                        <span className="font-bold text-sm">#{order.id}</span>
                        <span className="text-gray-500 text-sm">-</span>
                        <span className="text-gray-900 text-sm">
                          S/ {parseFloat(order.grand_total || order.total_amount || 0).toFixed(2)}
                        </span>
                        <span className="text-gray-500 text-sm">-</span>
                        <span className="text-gray-700 text-sm">
                          {order.waiter || 'Sin mesero'}
                        </span>
                      </div>
                      <div className="flex items-center gap-2">
                        {/* Bot√≥n editar - oculto para cajeros */}
                        {userRole !== 'cajeros' && (
                          <button
                            onClick={() => handleEditOrder(order)}
                            className="w-8 h-8 flex items-center justify-center text-gray-600 hover:text-gray-700 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors"
                            title="Editar pedido"
                          >
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
                                d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                            </svg>
                          </button>
                        )}
                        
                        {/* Bot√≥n eliminar - solo visible si todos los items est√°n en CREATED y no es cajero */}
                        {canDeleteOrder(order) && userRole !== 'cajeros' && (
                          <button
                            onClick={() => handleDeleteOrder(order)}
                            disabled={saving}
                            className="w-8 h-8 flex items-center justify-center text-red-500 hover:text-red-600 border border-red-300 rounded-lg hover:bg-red-50 transition-colors disabled:opacity-50"
                            title="Eliminar pedido"
                          >
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
                                d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                          </button>
                        )}
                        
                        {canProcessPayment(order) && hasPermission('canManagePayments') && (
                          <button
                            onClick={() => handleProcessPayment(order)}
                            className="w-8 h-8 flex items-center justify-center text-green-600 hover:text-green-700 border border-green-300 rounded-lg hover:bg-green-50 transition-colors"
                            title="Procesar pago"
                          >
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
                                d="M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z" />
                            </svg>
                          </button>
                        )}
                      </div>
                    </div>
                    
                    {/* MOSTRAR ITEMS DEL PEDIDO */}
                    {order.items && order.items.length > 0 && (
                      <div className="border-t pt-2 mt-2">
                        <div className="space-y-1">
                          {order.items.map((item, index) => (
                            <div key={item.id || index} className="flex justify-between text-sm">
                              <div className="flex items-center space-x-2">
                                <div 
                                  className={`w-2 h-2 rounded-full flex-shrink-0 ${getItemStatusColor(item.status)}`} 
                                  title={
                                    item.status === 'PAID' ? 'Pagado' :
                                    item.status === 'SERVED' ? 'Servido' : 
                                    item.status === 'PREPARING' ? 'En Preparaci√≥n' :
                                    item.status === 'CREATED' ? 'Pendiente' : 'Desconocido'
                                  }
                                />
                                <div className="flex items-center space-x-2 flex-1">
                                  <span className="text-gray-700">
                                    {item.recipe_name || item.recipe?.name} x{item.quantity}
                                    {item.notes && (
                                      <span className="text-gray-500 italic ml-1">({item.notes})</span>
                                    )}
                                  </span>
                                  {item.is_takeaway && (
                                    <div className="flex items-center bg-orange-100 text-orange-600 p-1 rounded-full" title="Para llevar">
                                      <svg className="w-2.5 h-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
                                      </svg>
                                    </div>
                                  )}
                                </div>
                              </div>
                              <div className="text-right">
                                <span className="text-gray-600">
                                  S/ {parseFloat(item.total_with_container || item.total_price || 0).toFixed(2)}
                                </span>
                                {item.container_info && item.container_info.total_price > 0 && (
                                  <div className="text-xs text-gray-500">
                                    Plato: S/ {parseFloat(item.total_price || 0).toFixed(2)} + Envase: S/ {parseFloat(item.container_info.total_price || 0).toFixed(2)}
                                  </div>
                                )}
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
            
            {/* Bot√≥n flotante "Nuevo Pedido" - oculto para cajeros */}
            {userRole !== 'cajeros' && (
              <div className="fixed bottom-4 right-4 z-40">
                <button
                  onClick={handleCreateNewOrder}
                  className="w-14 h-14 rounded-full shadow-lg bg-blue-600 hover:bg-blue-700 text-white transform hover:scale-110 transition-all duration-300 flex items-center justify-center"
                  title="Nuevo Pedido"
                >
                  <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M12 4v16m8-8H4" />
                  </svg>
                </button>
              </div>
            )}
          </div>
        )}

        {/* VISTA MEN√ö */}
        {step === 'menu' && (
          <div>
            {/* Buscador */}
            <input
              type="text"
              placeholder="Buscar plato..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full p-2 border rounded mb-4"
            />

            {/* Filtro de grupo */}
            <div className="mb-4">
              <select
                value={selectedGroup || ''}
                onChange={(e) => setSelectedGroup(e.target.value ? parseInt(e.target.value) : null)}
                className="w-full p-2 border border-gray-300 rounded-md focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
              >
                <option value="">Todos los grupos ({recipes.length})</option>
                {groups.map(group => (
                  <option key={group.id} value={group.id}>
                    {group.name} ({recipeCountByGroup[group.id] || 0})
                  </option>
                ))}
              </select>
            </div>

            {/* Lista de recetas - Redise√±ada con dos botones */}
            <div className="space-y-2 mb-20">
              {filteredRecipes.map(recipe => (
                <div key={recipe.id} className="bg-white border rounded p-3">
                  <div className="flex gap-2 h-16">
                    {/* Bot√≥n principal con nombre y precio */}
                    <button
                      onClick={() => addToCart(recipe)}
                      className="flex-1 flex flex-col justify-center p-3 text-left bg-gray-50 hover:bg-gray-100 border border-gray-300 rounded-lg transition-colors group"
                    >
                      <div className="font-semibold text-gray-900 group-hover:text-blue-600 transition-colors">
                        {recipe.name}
                      </div>
                      <div className="text-sm text-gray-600 mt-1">
                        S/ {recipe.price || recipe.base_price || '0.00'}
                      </div>
                    </button>
                    
                    {/* Bot√≥n de nota con l√°piz */}
                    <button
                      onClick={() => openNoteModal(recipe)}
                      className="w-16 h-16 flex items-center justify-center text-gray-600 hover:text-gray-700 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors"
                      title="Agregar nota"
                    >
                      <svg className="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                      </svg>
                    </button>
                  </div>
                </div>
              ))}
            </div>

            {/* El carrito ahora est√° integrado en el header */}

            {/* Panel lateral del carrito */}
            {isCartOpen && (
              <>
                {/* Overlay */}
                <div 
                  className="fixed inset-0 bg-black bg-opacity-50 z-[65]"
                  onClick={toggleCart}
                />
                
                {/* Panel lateral deslizante */}
                <div className="fixed inset-y-0 right-0 w-full sm:w-96 bg-white shadow-xl z-[70] transform transition-transform duration-300 ease-in-out flex flex-col">
                  {/* Header del panel lateral */}
                  <div className="bg-gray-50 px-4 py-4 border-b flex-shrink-0">
                    <div className="flex items-center justify-between">
                      <div className="flex-1 flex items-center justify-center">
                        <h2 className="text-lg font-semibold text-gray-800">
                          {currentOrder ? `Pedido #${currentOrder.id}` : 'Nuevo Pedido'}
                        </h2>
                      </div>
                      <button
                        onClick={toggleCart}
                        className="text-gray-600 hover:text-gray-800 p-2 hover:bg-gray-100 rounded-full transition-colors"
                        title="Cerrar panel"
                      >
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 19l-7-7 7-7m8 14l-7-7 7-7" />
                        </svg>
                      </button>
                    </div>
                  </div>

                  {/* Lista unificada de todos los items */}
                  <div className="flex-1 flex flex-col min-h-0">
                    {((currentOrder && currentOrder.items && currentOrder.items.length > 0) || cart.length > 0) ? (
                      <div className="flex-1 overflow-y-auto">
                        {/* Items existentes del pedido */}
                        {currentOrder && currentOrder.items && currentOrder.items.map((item, index) => {
                          const itemNumber = index + 1;
                          return (
                          <div key={`existing-${item.id || index}`} className="px-4 py-3 border-b border-gray-100 hover:bg-gray-50 transition-colors">
                            <div className="flex items-center gap-3">
                              {/* N√∫mero del item */}
                              <div className="flex-shrink-0 w-6 h-6 rounded-full bg-gray-100 text-gray-600 text-xs font-medium flex items-center justify-center">
                                {itemNumber}.
                              </div>
                              
                              {/* Estado del item */}
                              <div 
                                className={`w-3 h-3 rounded-full flex-shrink-0 ${
                                  getItemStatusColor(item.status)
                                }`} 
                                title={
                                  item.status === 'PAID' ? 'Pagado' :
                                  item.status === 'SERVED' ? 'Servido' : 
                                  item.status === 'PREPARING' ? 'En Preparaci√≥n' :
                                  item.status === 'CREATED' ? 'Pendiente' : 'Desconocido'
                                }
                              />
                              
                              {/* Info del item */}
                              <div className="flex-1 min-w-0">
                                <div className="flex items-center gap-2">
                                  <h4 className="text-sm font-medium text-gray-900 truncate">
                                    {item.recipe_name || item.recipe?.name}
                                  </h4>
                                  {item.is_takeaway && (
                                    <div className="flex items-center bg-orange-100 text-orange-600 p-1.5 rounded-full" title="Para llevar">
                                      <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
                                      </svg>
                                    </div>
                                  )}
                                </div>
                                <div className="text-xs text-gray-500">
                                  <p>x{item.quantity} ‚Ä¢ S/ {parseFloat(item.total_with_container || item.total_price || 0).toFixed(2)}</p>
                                  {item.container_info && item.container_info.total_price > 0 && (
                                    <p className="text-gray-400">Plato: S/ {parseFloat(item.total_price || 0).toFixed(2)} + Envase ({item.container_info.container_name}): S/ {parseFloat(item.container_info.total_price || 0).toFixed(2)}</p>
                                  )}
                                  {item.notes && (
                                    <span className="text-blue-600 italic">‚Ä¢ {item.notes}</span>
                                  )}
                                </div>
                              </div>
                              
                              {/* Bot√≥n eliminar solo si est√° CREATED y no es cajero */}
                              {canDeleteItem(item) && userRole !== 'cajeros' && (
                                <button
                                  onClick={() => handleDeleteOrderItem(item.id)}
                                  disabled={saving}
                                  className="w-7 h-7 bg-red-50 hover:bg-red-100 text-red-500 rounded-full flex items-center justify-center transition-colors disabled:opacity-50"
                                >
                                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                  </svg>
                                </button>
                              )}
                            </div>
                          </div>
                        );})}
                        
                        {/* Items nuevos en carrito */}
                        {cart.map((item, index) => {
                          // Calcular el n√∫mero considerando items existentes
                          const existingItemsCount = (currentOrder && currentOrder.items) ? currentOrder.items.length : 0;
                          const itemNumber = existingItemsCount + index + 1;
                          return (
                          <div key={`cart-${index}`} className="px-4 py-3 border-b border-gray-100 hover:bg-gray-50 transition-colors">
                            <div className="flex items-center gap-3">
                              {/* N√∫mero del item */}
                              <div className="flex-shrink-0 w-6 h-6 rounded-full bg-blue-100 text-blue-600 text-xs font-medium flex items-center justify-center">
                                {itemNumber}.
                              </div>
                              
                              {/* Indicador de nuevo item */}
                              <div 
                                className={`w-3 h-3 rounded-full flex-shrink-0 ${getItemStatusColor('CREATED')}`} 
                                title="Nuevo item"
                              />
                              
                              {/* Info del item */}
                              <div className="flex-1 min-w-0">
                                <div className="flex items-center gap-2">
                                  <h4 className="text-sm font-medium text-gray-900 truncate">
                                    {item.recipe.name}
                                  </h4>
                                  {item.is_takeaway && (
                                    <div className="flex items-center bg-orange-100 text-orange-600 p-1.5 rounded-full" title="Para llevar">
                                      <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
                                      </svg>
                                    </div>
                                  )}
                                </div>
                                <p className="text-xs text-gray-500">
                                  x{item.quantity} ‚Ä¢ S/ {(item.unit_price * item.quantity).toFixed(2)}
                                  {item.notes && (
                                    <span className="text-blue-600 italic ml-1">‚Ä¢ {item.notes}</span>
                                  )}
                                </p>
                              </div>
                              
                              {/* Bot√≥n eliminar */}
                              <div className="flex items-center">
                                <button
                                  onClick={() => removeFromCart(index)}
                                  className="w-7 h-7 bg-red-50 hover:bg-red-100 text-red-500 rounded-full flex items-center justify-center transition-colors"
                                >
                                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                  </svg>
                                </button>
                              </div>
                            </div>
                          </div>
                        );})}
                      </div>
                    ) : (
                      <div className="flex-1 flex items-center justify-center text-gray-500">
                        <div className="text-center">
                          <svg className="w-12 h-12 mx-auto mb-3 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1} d="M3 3h2l.4 2M7 13h10l4-8H5.4m0 0L7 13m0 0l-1.5 1.5M7 13l-1.5 1.5M16.5 14.5a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0zm-9.75 0a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0z" />
                          </svg>
                          <p className="text-sm">El carrito est√° vac√≠o</p>
                          <p className="text-xs mt-1">Agrega items desde el men√∫</p>
                        </div>
                      </div>
                    )}
                  </div>

                  {/* Footer con total y bot√≥n de acci√≥n - Estilo negro minimalista */}
                  <div className="p-4 bg-gray-50 flex-shrink-0">
                    {/* Total con estilo minimalista */}
                    <div className="bg-gray-50 rounded-xl p-3 mb-3">
                      <div className="flex justify-between items-center">
                        <span className="text-sm text-gray-600">Total</span>
                        <span className="text-lg font-semibold text-gray-900">
                          S/ {getCompleteTotal.toFixed(2)}
                        </span>
                      </div>
                    </div>
                    
                    {/* Bot√≥n de acci√≥n estilo negro - oculto para cajeros */}
                    {cart.length > 0 && userRole !== 'cajeros' && (
                      <button
                        onClick={saveOrder}
                        disabled={saving}
                        className={`w-full py-3 px-4 rounded-xl transition-all duration-200 flex items-center justify-center gap-2 font-medium text-sm ${
                          !saving
                            ? 'bg-gray-900 text-white hover:bg-gray-800 active:bg-gray-700'
                            : 'bg-gray-700 text-gray-400'
                        } disabled:opacity-50`}
                      >
                        {saving ? (
                          <>
                            <div className="w-4 h-4 border-2 border-current border-t-transparent rounded-full animate-spin"></div>
                            <span>Guardando...</span>
                          </>
                        ) : (
                          <>
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                            </svg>
                            <span>{currentOrder ? 'Actualizar Pedido' : 'Crear Pedido'}</span>
                          </>
                        )}
                      </button>
                    )}
                  </div>
                </div>
              </>
            )}
          </div>
        )}

        {/* VISTA PAGO */}
        {step === 'payment' && selectedOrderForPayment && (
          <div className="space-y-3">
            {/* Informaci√≥n del pedido minimalista */}
            <div className="flex justify-between items-center text-sm">
              <span className="font-medium text-gray-900">
                Pedido #{selectedOrderForPayment.id} - Mesa {selectedTable?.table_number}
              </span>
              <span className="text-gray-600">
                Total: S/ {selectedOrderForPayment.items
                  ?.reduce((sum, item) => sum + parseFloat(item.total_with_container || item.total_price || 0), 0)
                  .toFixed(2) || '0.00'}
              </span>
            </div>

            {/* Lista de items minimalista */}
            <div className="bg-white border border-gray-200">
              {selectedOrderForPayment.items.filter(item => item.status === 'SERVED' && !item.is_fully_paid).length > 0 && (
                <div className="p-2 border-b bg-gray-50 flex justify-between items-center">
                  <span className="text-xs text-gray-600">Seleccionar para pago</span>
                  <button
                    onClick={handleSelectAllServedItems}
                    className="text-xs text-blue-600 hover:text-blue-700"
                  >
                    {selectedOrderForPayment.items
                      .filter(item => item.status === 'SERVED' && !item.is_fully_paid)
                      .every(item => selectedItems.includes(item.id))
                      ? 'Deseleccionar' 
                      : 'Seleccionar todos'
                    }
                  </button>
                </div>
              )}

              <div className="divide-y">
                {/* Items SERVED (disponibles para pago) */}
                {selectedOrderForPayment.items
                  .filter(item => item.status === 'SERVED' && !item.is_fully_paid)
                  .map(item => (
                    <div key={item.id} className="p-2 hover:bg-gray-50">
                      <div className="flex items-center gap-2">
                        <input
                          type="checkbox"
                          checked={selectedItems.includes(item.id)}
                          onChange={() => handleItemSelection(item.id)}
                          className="h-3 w-3 text-blue-600 border-gray-300 rounded"
                        />
                        <div 
                          className={`w-2 h-2 rounded-full flex-shrink-0 ${getItemStatusColor('SERVED')}`} 
                          title="Servido"
                        />
                        <div className="flex-1 min-w-0 flex justify-between items-center">
                          <div className="flex-1 min-w-0">
                            <div className="text-sm text-gray-900 truncate">
                              {item.quantity}x {item.recipe_name}
                              {item.is_takeaway && (
                                <span className="text-xs text-blue-600 ml-1">(para llevar)</span>
                              )}
                            </div>
                            {item.notes && (
                              <div className="text-xs text-gray-500 italic truncate">{item.notes}</div>
                            )}
                          </div>
                          <div className="text-sm font-medium text-gray-900 ml-2">
                            S/ {parseFloat(item.total_with_container || item.total_price || 0).toFixed(2)}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))
                }

                {/* Items ya PAID (bloqueados) */}
                {selectedOrderForPayment.items
                  .filter(item => item.status === 'PAID' || item.is_fully_paid)
                  .map(item => (
                    <div key={item.id} className="p-2 bg-gray-50 opacity-70">
                      <div className="flex items-center gap-2">
                        <input
                          type="checkbox"
                          disabled
                          checked={false}
                          className="h-3 w-3 text-gray-400 border-gray-300 rounded opacity-50 cursor-not-allowed"
                        />
                        <div 
                          className={`w-2 h-2 rounded-full flex-shrink-0 ${getItemStatusColor('PAID')}`} 
                          title="Pagado"
                        />
                        <div className="flex-1 min-w-0 flex justify-between items-center">
                          <div className="flex-1 min-w-0">
                            <div className="text-sm text-gray-600 truncate">
                              {item.quantity}x {item.recipe_name}
                              {item.is_takeaway && (
                                <span className="text-xs text-blue-600 ml-1">(para llevar)</span>
                              )}
                            </div>
                            {item.notes && (
                              <div className="text-xs text-gray-500 italic truncate">{item.notes}</div>
                            )}
                          </div>
                          <div className="text-sm font-medium text-gray-600 ml-2">
                            S/ {parseFloat(item.total_with_container || item.total_price || 0).toFixed(2)}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))
                }

                {/* Items PREPARING (no disponibles) */}
                {selectedOrderForPayment.items
                  .filter(item => item.status === 'PREPARING')
                  .map(item => (
                    <div key={item.id} className="p-2 bg-gray-50 opacity-60">
                      <div className="flex items-center gap-2">
                        <input
                          type="checkbox"
                          disabled
                          checked={false}
                          className="h-3 w-3 text-gray-400 border-gray-300 rounded opacity-50 cursor-not-allowed"
                        />
                        <div 
                          className={`w-2 h-2 rounded-full flex-shrink-0 ${getItemStatusColor('PREPARING')}`} 
                          title="En Preparaci√≥n"
                        />
                        <div className="flex-1 min-w-0 flex justify-between items-center">
                          <div className="flex-1 min-w-0">
                            <div className="text-sm text-gray-600 truncate">
                              {item.quantity}x {item.recipe_name}
                              {item.is_takeaway && (
                                <span className="text-xs text-blue-600 ml-1">(para llevar)</span>
                              )}
                            </div>
                            {item.notes && (
                              <div className="text-xs text-gray-500 italic truncate">{item.notes}</div>
                            )}
                          </div>
                          <div className="text-sm font-medium text-gray-600 ml-2">
                            S/ {parseFloat(item.total_with_container || item.total_price || 0).toFixed(2)}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))
                }

                {/* Items CREATED (no disponibles) */}
                {selectedOrderForPayment.items
                  .filter(item => item.status === 'CREATED')
                  .map(item => (
                    <div key={item.id} className="p-2 bg-gray-50 opacity-60">
                      <div className="flex items-center gap-2">
                        <input
                          type="checkbox"
                          disabled
                          checked={false}
                          className="h-3 w-3 text-gray-400 border-gray-300 rounded opacity-50 cursor-not-allowed"
                        />
                        <div 
                          className={`w-2 h-2 rounded-full flex-shrink-0 ${getItemStatusColor('CREATED')}`} 
                          title="Pendiente"
                        />
                        <div className="flex-1 min-w-0 flex justify-between items-center">
                          <div className="flex-1 min-w-0">
                            <div className="text-sm text-gray-600 truncate">
                              {item.quantity}x {item.recipe_name}
                              {item.is_takeaway && (
                                <span className="text-xs text-blue-600 ml-1">(para llevar)</span>
                              )}
                            </div>
                            {item.notes && (
                              <div className="text-xs text-gray-500 italic truncate">{item.notes}</div>
                            )}
                          </div>
                          <div className="text-sm font-medium text-gray-600 ml-2">
                            S/ {parseFloat(item.total_with_container || item.total_price || 0).toFixed(2)}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))
                }
              </div>

              {selectedOrderForPayment.items.filter(item => item.status === 'SERVED' && !item.is_fully_paid).length === 0 && (
                <div className="p-8 text-center text-gray-500">
                  {selectedOrderForPayment.items.filter(item => item.is_fully_paid).length > 0 
                    ? 'Todos los items disponibles ya han sido pagados'
                    : 'No hay items listos para pago'
                  }
                </div>
              )}
            </div>

            {/* Configuraci√≥n de pago minimalista */}
            {selectedItems.length > 0 && (
              <div className="bg-white border border-gray-200 p-2 space-y-2">
                <div className="flex justify-between items-center text-sm">
                  <span className="text-gray-600">{selectedItems.length} item(s)</span>
                  <span className="font-medium text-gray-900">
                    S/ {selectedOrderForPayment.items
                      .filter(item => selectedItems.includes(item.id))
                      .reduce((sum, item) => sum + parseFloat(item.total_with_container || item.total_price || 0), 0)
                      .toFixed(2)
                    }
                  </span>
                </div>

                {/* M√©todo de pago */}
                <div>
                  <div className="flex gap-1">
                    {[
                      { value: 'CASH', label: 'Efectivo' },
                      { value: 'CARD', label: 'Tarjeta' },
                      { value: 'YAPE_PLIN', label: 'Yape' },
                      { value: 'TRANSFER', label: 'Transfer' }
                    ].map(method => (
                      <button
                        key={method.value}
                        onClick={() => setPaymentMethod(method.value)}
                        className={`flex-1 py-2 px-3 text-sm border rounded ${
                          paymentMethod === method.value
                            ? 'border-blue-500 bg-blue-50 text-blue-700'
                            : 'border-gray-300 text-gray-700 hover:bg-gray-50'
                        }`}
                      >
                        {method.label}
                      </button>
                    ))}
                  </div>
                </div>

                {/* Descripci√≥n/Notas minimalista */}
                <div>
                  <textarea
                    value={paymentDescription}
                    onChange={(e) => setPaymentDescription(e.target.value)}
                    className="w-full px-3 py-2 text-sm border border-gray-300 rounded focus:border-blue-500 outline-none"
                    placeholder="Notas adicionales..."
                    rows={2}
                  />
                </div>

                {/* Opciones minimalistas */}
                <div className="flex items-center justify-between text-xs">
                  <div className="flex items-center gap-2">
                    <input
                      type="checkbox"
                      id="withPrinting"
                      checked={withPrinting}
                      onChange={(e) => {
                        const checked = e.target.checked;
                        setWithPrinting(checked);
                        handleBluetoothToggle(checked);
                      }}
                      disabled={connectingBluetooth}
                      className="h-4 w-4 text-blue-600 border-gray-300 rounded disabled:opacity-50"
                    />
                    <label htmlFor="withPrinting" className="text-sm text-gray-700">
                      Imprimir
                    </label>
                    {/* Estado de conexi√≥n Bluetooth */}
                    {withPrinting && (
                      <span className="text-xs">
                        {connectingBluetooth ? (
                          <span className="text-yellow-600">Conectando...</span>
                        ) : bluetoothConnected ? (
                          <span className="text-green-600">‚úì</span>
                        ) : (
                          <span className="text-red-600">‚úó</span>
                        )}
                      </span>
                    )}
                  </div>
                </div>

                {/* Bot√≥n procesar pago */}
                <button
                  onClick={handleProcessSelectedPayment}
                  disabled={paymentProcessing}
                  className="w-full bg-green-600 text-white py-3 px-4 text-base rounded hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {paymentProcessing ? 'Procesando...' : 'Procesar Pago'}
                </button>
              </div>
            )}

            {/* Bot√≥n imprimir comprobante completo cuando todo est√° pagado */}
            {areAllItemsPaid(selectedOrderForPayment) && (
              <div className="mt-2">
                <button
                  onClick={printFullReceipt}
                  className="w-full bg-blue-600 text-white py-2 px-3 text-sm hover:bg-blue-700"
                >
                  Imprimir Comprobante Completo
                </button>
              </div>
            )}
          </div>
        )}
      </div>

      {/* Modal simplificado */}
      {isNoteModalOpen && (
        <div className="fixed inset-0 z-[80] flex items-center justify-center p-4 bg-black bg-opacity-50">
          <div className="bg-white rounded-lg w-full max-w-md p-6">
            {/* Header */}
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-semibold">{selectedRecipe?.name}</h3>
              <button onClick={closeNoteModal} className="text-gray-500 hover:text-gray-700">
                ‚úï
              </button>
            </div>

            {/* Delivery checkbox */}
            <div className="mb-4">
              <label className="flex items-center gap-3 cursor-pointer">
                <input
                  type="checkbox"
                  checked={isTakeaway}
                  onChange={(e) => setIsTakeaway(e.target.checked)}
                  className="w-5 h-5"
                />
                <span className="text-sm font-medium">Delivery</span>
                {isTakeaway && containers.length > 0 && (
                  <span className="text-sm text-gray-500">
                    (+S/{getSelectedContainer(selectedRecipe)?.price || 0})
                  </span>
                )}
              </label>
            </div>

            {/* Comentario */}
            <div className="mb-4">
              <label className="block text-sm font-medium mb-2">Comentario</label>
              <textarea
                value={noteText}
                onChange={(e) => setNoteText(e.target.value)}
                placeholder="Ej: Sin cebolla, extra salsa..."
                className="w-full p-3 border rounded-lg resize-none"
                rows="3"
              />
            </div>

            {/* Total */}
            <div className="mb-6 p-3 bg-gray-50 rounded-lg">
              <div className="flex justify-between">
                <span>Total:</span>
                <span className="font-semibold">
                  S/ {(
                    parseFloat(selectedRecipe?.price || selectedRecipe?.base_price || 0) +
                    (isTakeaway ? parseFloat(getSelectedContainer(selectedRecipe)?.price || 0) : 0)
                  ).toFixed(2)}
                </span>
              </div>
            </div>

            {/* Botones */}
            <div className="flex gap-3">
              <button
                onClick={closeNoteModal}
                className="flex-1 py-2 px-4 border border-gray-300 rounded-lg hover:bg-gray-50"
              >
                Cancelar
              </button>
              <button
                onClick={handleAddWithNotes}
                className="flex-1 py-2 px-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
              >
                Agregar
              </button>
            </div>
          </div>
        </div>
      )}

    </div>
  );
};

export default TableOrderEcommerce;