name: Professional Restaurant Web Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      action:
        description: 'Deployment Action'
        type: choice
        default: 'deploy'
        options:
          - deploy
          - status
          - logs
          - backup
          - restart
          - ssl-install
          - ssl-renew
          - ssl-test

env:
  AWS_REGION: us-west-2
  ECR_REGISTRY: 721063839441.dkr.ecr.us-west-2.amazonaws.com
  ECR_REPOSITORY: restaurant-web

jobs:
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # INTELLIGENT CHANGE DETECTION
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  
  analyze-changes:
    runs-on: ubuntu-latest
    name: Analyze Changes
    outputs:
      needs-build: ${{ steps.changes.outputs.needs-build }}
      changes: ${{ steps.changes.outputs.changes }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2
        
    - name: Detect changes
      id: changes
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "needs-build=true" >> $GITHUB_OUTPUT
          echo "changes=frontend backend infrastructure" >> $GITHUB_OUTPUT
          echo "ðŸ”§ Manual dispatch - building all components"
          exit 0
        fi
        
        # Get changed files
        changes=$(git diff --name-only HEAD~1 HEAD || echo "")
        components=""
        
        # Analyze changes
        if echo "$changes" | grep -qE "^(frontend/|package\.json)"; then
          components="$components frontend"
          echo "ðŸŽ¨ Frontend changes detected"
        fi
        
        if echo "$changes" | grep -qE "^(backend/|requirements\.txt)"; then
          components="$components backend"
          echo "ðŸ”§ Backend changes detected"
        fi
        
        if echo "$changes" | grep -qE "^(docker/|Dockerfile|\.github/)"; then
          components="$components infrastructure"
          echo "ðŸ—ï¸ Infrastructure changes detected"
        fi
        
        # Output results
        if [ -n "$components" ]; then
          echo "needs-build=true" >> $GITHUB_OUTPUT
          echo "changes=$components" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Components to deploy:$components"
        else
          echo "needs-build=false" >> $GITHUB_OUTPUT
          echo "changes=" >> $GITHUB_OUTPUT
          echo "â­ï¸ No significant changes detected, skipping build"
        fi

  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # OPTIMIZED BUILD AND DEPLOY
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  
  deploy:
    needs: analyze-changes
    runs-on: ubuntu-latest
    name: Professional Deployment
    environment: production
    if: needs.analyze-changes.outputs.needs-build == 'true' || github.event.inputs.action != ''
    
    steps:
    - name: ðŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ðŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ðŸš¢ Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: ðŸ—ï¸ Intelligent Build and Push
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        VITE_AWS_COGNITO_USER_POOL_ID: ${{ secrets.COGNITO_USER_POOL_ID }}
        VITE_AWS_COGNITO_APP_CLIENT_ID: ${{ secrets.COGNITO_APP_CLIENT_ID }}
        CHANGES: ${{ needs.analyze-changes.outputs.changes || 'frontend backend infrastructure' }}
      run: |
        echo "ðŸ” Building components: $CHANGES"
        
        # Conditional frontend build (only if frontend changed)
        if echo "$CHANGES" | grep -q "frontend" || [ "${{ github.event.inputs.action }}" = "deploy" ] || [ "${{ github.event.inputs.action }}" = "" ]; then
          echo "ðŸŽ¨ Building frontend with optimized settings..."
          cd frontend
          
          # Use npm ci for faster, reliable installs
          npm ci --prefer-offline --no-audit
          
          # Memory-optimized build with Cognito credentials
          NODE_OPTIONS='--max-old-space-size=6144' npm run build
          cd ..
          
          echo "âœ… Frontend build completed"
        else
          echo "â­ï¸ Skipping frontend build (no changes detected)"
        fi
        
        # Build and push Docker image
        echo "ðŸš¢ Building and pushing Docker image..."
        docker build \
          --cache-from $ECR_REGISTRY/$ECR_REPOSITORY:latest \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
          --build-arg BUILDKIT_INLINE_CACHE=1 \
          -f Dockerfile.prod .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "âœ… Docker image pushed successfully"

    - name: ðŸš€ Professional EC2 Deployment
      env:
        ACTION: ${{ github.event.inputs.action || 'deploy' }}
        EC2_HOST: ${{ secrets.EC2_PROD_HOST }}
        EC2_USER: ${{ secrets.EC2_USERNAME }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
      run: |
        echo "ðŸ” Setting up secure SSH connection..."
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts
        
        echo "ðŸ“¡ Creating secure deployment payload with JSON..."
        DEPLOYMENT_DATA=$(jq -n \
          --arg ecr_registry "$ECR_REGISTRY" \
          --arg ecr_repository "$ECR_REPOSITORY" \
          --arg action "$ACTION" \
          '{
            ecr_registry: $ecr_registry,
            ecr_repository: $ecr_repository,
            action: $action
          }')
        
        echo "ðŸ“¡ Executing professional deployment on EC2..."
        ssh -o ConnectTimeout=30 -o ServerAliveInterval=60 $EC2_USER@$EC2_HOST << DEPLOY_EOF
        set -e
        export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
        cd /opt/restaurant-web
        
        # Extract variables safely from JSON payload (secure against special characters)
        DEPLOYMENT_JSON='$DEPLOYMENT_DATA'
        export ECR_REGISTRY=\$(echo "\$DEPLOYMENT_JSON" | jq -r '.ecr_registry')
        export ECR_REPOSITORY=\$(echo "\$DEPLOYMENT_JSON" | jq -r '.ecr_repository')
        export ACTION=\$(echo "\$DEPLOYMENT_JSON" | jq -r '.action')
        
        echo "ðŸš€ Executing direct deployment without external scripts..."
        
        # Validate JSON extraction was successful
        if [ "\$ECR_REGISTRY" = "null" ] || [ -z "\$ECR_REGISTRY" ]; then
          echo "âŒ ERROR: Failed to extract ECR_REGISTRY from JSON payload"
          echo "Raw JSON: \$DEPLOYMENT_JSON"
          exit 1
        fi
        
        echo "ðŸ” Debug: ECR_REGISTRY=\$ECR_REGISTRY"
        echo "ðŸ” Debug: ECR_REPOSITORY=\$ECR_REPOSITORY" 
        echo "ðŸ” Debug: ACTION=\$ACTION"
        
        # Create necessary directory structure
        mkdir -p docker data logs
        
        # Create production environment file
        echo "# Restaurant Web Production Configuration" > .env.ec2
        echo "SECRET_KEY=prod-secret-key-change-in-production" >> .env.ec2
        echo "DEBUG=False" >> .env.ec2
        echo "USE_COGNITO_AUTH=True" >> .env.ec2
        echo "COGNITO_USER_POOL_ID=will-be-set-by-secrets" >> .env.ec2
        echo "COGNITO_APP_CLIENT_ID=will-be-set-by-secrets" >> .env.ec2
        echo "AWS_REGION=us-west-2" >> .env.ec2
        echo "ALLOWED_HOSTS=localhost,127.0.0.1,xn--elfogndedonsoto-zrb.com,www.xn--elfogndedonsoto-zrb.com,44.248.47.186" >> .env.ec2
        echo "DATABASE_PATH=/opt/restaurant-web/data" >> .env.ec2
        echo "DATABASE_NAME=restaurant.prod.sqlite3" >> .env.ec2
        
        # Remove any existing docker-compose.prod.yml and recreate
        rm -f docker/docker-compose.prod.yml
        
        # Create docker-compose.prod.yml dynamically
        echo "services:" > docker/docker-compose.prod.yml
        echo "  app:" >> docker/docker-compose.prod.yml
        echo "    image: \${ECR_REGISTRY}/restaurant-web:latest" >> docker/docker-compose.prod.yml
        echo "    container_name: restaurant-web-app" >> docker/docker-compose.prod.yml
        echo "    ports:" >> docker/docker-compose.prod.yml
        echo "      - '8000:8000'" >> docker/docker-compose.prod.yml
        echo "    volumes:" >> docker/docker-compose.prod.yml
        echo "      - ./data:/opt/restaurant-web/data" >> docker/docker-compose.prod.yml
        echo "      - ./logs:/opt/restaurant-web/logs" >> docker/docker-compose.prod.yml
        echo "    environment:" >> docker/docker-compose.prod.yml
        echo "      - DATABASE_PATH=/opt/restaurant-web/data" >> docker/docker-compose.prod.yml
        echo "      - DATABASE_NAME=restaurant.prod.sqlite3" >> docker/docker-compose.prod.yml
        echo "    env_file:" >> docker/docker-compose.prod.yml
        echo "      - /opt/restaurant-web/.env.ec2" >> docker/docker-compose.prod.yml
        echo "    restart: unless-stopped" >> docker/docker-compose.prod.yml
        echo "    profiles:" >> docker/docker-compose.prod.yml
        echo "      - production" >> docker/docker-compose.prod.yml
        echo "    healthcheck:" >> docker/docker-compose.prod.yml
        echo "      test: ['CMD', 'curl', '-f', 'http://localhost:8000/api/v1/health/']" >> docker/docker-compose.prod.yml
        echo "      interval: 30s" >> docker/docker-compose.prod.yml
        echo "      timeout: 10s" >> docker/docker-compose.prod.yml
        echo "      retries: 5" >> docker/docker-compose.prod.yml
        echo "      start_period: 60s" >> docker/docker-compose.prod.yml
        echo "  nginx:" >> docker/docker-compose.prod.yml
        echo "    image: nginx:alpine" >> docker/docker-compose.prod.yml
        echo "    container_name: restaurant-web-nginx" >> docker/docker-compose.prod.yml
        echo "    ports:" >> docker/docker-compose.prod.yml
        echo "      - '80:80'" >> docker/docker-compose.prod.yml
        echo "      - '443:443'" >> docker/docker-compose.prod.yml
        echo "    volumes:" >> docker/docker-compose.prod.yml
        echo "      - ./nginx/conf.d:/etc/nginx/conf.d:ro" >> docker/docker-compose.prod.yml
        echo "      - ./nginx/ssl:/etc/nginx/ssl:ro" >> docker/docker-compose.prod.yml
        echo "      - ./data/certbot/www:/var/www/certbot:ro" >> docker/docker-compose.prod.yml
        echo "      - ./data/certbot/conf:/etc/letsencrypt:ro" >> docker/docker-compose.prod.yml
        echo "    depends_on:" >> docker/docker-compose.prod.yml
        echo "      - app" >> docker/docker-compose.prod.yml
        echo "    restart: unless-stopped" >> docker/docker-compose.prod.yml
        echo "    profiles:" >> docker/docker-compose.prod.yml
        echo "      - production" >> docker/docker-compose.prod.yml
        echo "volumes:" >> docker/docker-compose.prod.yml
        echo "  restaurant_data:" >> docker/docker-compose.prod.yml
        echo "    driver: local" >> docker/docker-compose.prod.yml
        echo "  restaurant_logs:" >> docker/docker-compose.prod.yml
        echo "    driver: local" >> docker/docker-compose.prod.yml
        echo "networks:" >> docker/docker-compose.prod.yml
        echo "  default:" >> docker/docker-compose.prod.yml
        echo "    name: restaurant-network" >> docker/docker-compose.prod.yml
        
        # Debug: Show what we created
        echo "ðŸ” Debug: Contents of docker-compose.prod.yml:"
        cat docker/docker-compose.prod.yml
        echo "ðŸ” Debug: Contents of .env.ec2:"
        cat .env.ec2
          
        # Create nginx config with printf for exact control
        mkdir -p docker/nginx/conf.d
        printf 'server {\\n  listen 80;\\n  server_name xn--elfogndedonsoto-zrb.com www.xn--elfogndedonsoto-zrb.com _;\\n  location /.well-known/acme-challenge/ { root /var/www/certbot; }\\n  location /api/ {\\n    proxy_pass http://app:8000;\\n    proxy_set_header Host \\$host;\\n    proxy_set_header X-Real-IP \\$remote_addr;\\n    proxy_set_header X-Forwarded-For \\$proxy_add_x_forwarded_for;\\n  }\\n  location /admin/ { proxy_pass http://app:8000; proxy_set_header Host \\$host; }\\n  location /static/ { proxy_pass http://app:8000; }\\n  location /media/ { proxy_pass http://app:8000; }\\n  location / {\\n    proxy_pass http://app:8000;\\n    proxy_set_header Host \\$host;\\n    proxy_set_header X-Real-IP \\$remote_addr;\\n    proxy_set_header X-Forwarded-For \\$proxy_add_x_forwarded_for;\\n  }\\n}\\n' > docker/nginx/conf.d/default.conf
          
        # Execute deployment directly
        echo "ðŸ” Logging into ECR..."
        aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin \$ECR_REGISTRY
        
        echo "ðŸ“¥ Pulling latest Docker image..."
        docker pull \$ECR_REGISTRY/\$ECR_REPOSITORY:latest
        
        echo "ðŸ›‘ Stopping and removing existing containers..."
        docker-compose -f docker/docker-compose.prod.yml --profile production down --timeout 10 || true
        
        # Force remove any lingering containers
        docker rm -f restaurant-web-app restaurant-web-nginx 2>/dev/null || true
        
        echo "â–¶ï¸ Starting production services..."
        docker-compose -f docker/docker-compose.prod.yml --profile production up -d --force-recreate --remove-orphans
        
        echo "â³ Health check..."
        sleep 15
        
        for i in {1..6}; do
          echo "ðŸ” Health check attempt $i/6..."
          docker-compose -f docker/docker-compose.prod.yml --profile production ps
          
          # Check if containers are running and healthy
          if docker-compose -f docker/docker-compose.prod.yml --profile production ps | grep -q "Up.*healthy"; then
            echo "âœ… Django container is healthy"
            
            # Check if nginx is running
            if docker-compose -f docker/docker-compose.prod.yml --profile production ps nginx | grep -q "Up"; then
              echo "âœ… Nginx container is running"
              
              # Test direct Django health first
              if curl -sf http://localhost:8000/api/v1/health/ --connect-timeout 5 --max-time 10; then
                echo "âœ… Django health check works directly"
                
                # Test via nginx proxy
                if curl -sf http://localhost/api/v1/health/ --connect-timeout 5 --max-time 10; then
                  echo "âœ… Deployment successful!"
                  docker-compose -f docker/docker-compose.prod.yml --profile production ps
                  exit 0
                else
                  echo "âŒ Nginx proxy not working - checking nginx logs"
                  docker-compose -f docker/docker-compose.prod.yml --profile production logs nginx --tail=10
                fi
              else
                echo "âŒ Django not responding on port 8000"
                docker-compose -f docker/docker-compose.prod.yml --profile production logs app --tail=10
              fi
            else
              echo "âŒ Nginx container not running"
              docker-compose -f docker/docker-compose.prod.yml --profile production logs nginx --tail=10
            fi
          else
            echo "âš ï¸ Django container not healthy yet"
          fi
          echo "Health check $i/6 failed, waiting..."
          sleep 10
        done
        
        echo "âŒ Health check failed"
        docker-compose -f docker/docker-compose.prod.yml --profile production logs app --tail=20
        exit 1
        DEPLOY_EOF
        
        echo "âœ… Professional deployment completed successfully"

    - name: ðŸ“Š Deployment Summary
      if: always()
      run: |
        echo "## ðŸŒŸ Professional Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Action:** ${{ env.ACTION || 'deploy' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Changes Detected:** ${{ needs.analyze-changes.outputs.changes || 'manual deployment' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
        echo "- **Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ”— **Live Site:** https://www.xn--elfogndedonsoto-zrb.com/" >> $GITHUB_STEP_SUMMARY