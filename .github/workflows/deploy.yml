name: Restaurant Web Deployment

on:
  push:
    branches: [ main ]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - 'docker/**'
      - 'Dockerfile*'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      action:
        description: 'Deployment Action'
        type: choice
        default: 'deploy'
        options:
          - deploy
          - rollback
          - status
          - logs
          - restart
      skip_tests:
        description: 'Skip tests (emergency deploy)'
        type: boolean
        default: false

env:
  AWS_REGION: us-west-2
  ECR_REGISTRY: 721063839441.dkr.ecr.us-west-2.amazonaws.com
  ECR_REPOSITORY: restaurant-web
  NODE_OPTIONS: '--max-old-space-size=4096'
  DOCKER_BUILDKIT: 1

jobs:
  # Run tests first (can be skipped for emergency deploys)
  test:
    uses: ./.github/workflows/test.yml
    with:
      skip_tests: ${{ github.event.inputs.skip_tests == 'true' }}

  # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  # INTELLIGENT CHANGE DETECTION
  # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  
  analyze-changes:
    needs: test
    runs-on: ubuntu-latest
    name: Analyze Changes
    outputs:
      needs-build: ${{ steps.changes.outputs.needs-build }}
      changes: ${{ steps.changes.outputs.changes }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2
        
    - name: Detect changes
      id: changes
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "needs-build=true" >> $GITHUB_OUTPUT
          echo "changes=frontend backend infrastructure" >> $GITHUB_OUTPUT
          echo "üîß Manual dispatch - building all components"
          exit 0
        fi
        
        # Get changed files
        changes=$(git diff --name-only HEAD~1 HEAD || echo "")
        components=""
        
        # Analyze changes
        if echo "$changes" | grep -qE "^(frontend/|package\.json)"; then
          components="$components frontend"
          echo "üé® Frontend changes detected"
        fi
        
        if echo "$changes" | grep -qE "^(backend/|requirements\.txt)"; then
          components="$components backend"
          echo "üîß Backend changes detected"
        fi
        
        if echo "$changes" | grep -qE "^(docker/|Dockerfile|\.github/)"; then
          components="$components infrastructure"
          echo "üèóÔ∏è Infrastructure changes detected"
        fi
        
        # Output results
        if [ -n "$components" ]; then
          echo "needs-build=true" >> $GITHUB_OUTPUT
          echo "changes=$components" >> $GITHUB_OUTPUT
          echo "üì¶ Components to deploy:$components"
        else
          echo "needs-build=false" >> $GITHUB_OUTPUT
          echo "changes=" >> $GITHUB_OUTPUT
          echo "‚è≠Ô∏è No significant changes detected, skipping build"
        fi

  # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  # OPTIMIZED BUILD AND DEPLOY
  # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  
  deploy:
    needs: [test, analyze-changes]
    runs-on: ubuntu-latest
    name: Production Deployment
    environment: production
    if: (needs.analyze-changes.outputs.needs-build == 'true' || github.event.inputs.action != '') && (success() || github.event.inputs.skip_tests == 'true')
    
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
    
    - name: üíæ Setup Node.js with caching
      if: contains(needs.analyze-changes.outputs.changes, 'frontend') || github.event.inputs.action == 'deploy' || github.event.inputs.action == ''
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üö¢ Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: üèóÔ∏è Intelligent Build and Push
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        VITE_AWS_COGNITO_USER_POOL_ID: ${{ secrets.COGNITO_USER_POOL_ID }}
        VITE_AWS_COGNITO_APP_CLIENT_ID: ${{ secrets.COGNITO_APP_CLIENT_ID }}
        CHANGES: ${{ needs.analyze-changes.outputs.changes || 'frontend backend infrastructure' }}
      run: |
        echo "üîç Building components: $CHANGES"
        
        # Conditional frontend build (only if frontend changed)
        if echo "$CHANGES" | grep -q "frontend" || [ "${{ github.event.inputs.action }}" = "deploy" ] || [ "${{ github.event.inputs.action }}" = "" ]; then
          echo "üé® Building frontend with optimized settings..."
          cd frontend
          
          # Optimized npm install with caching
          npm ci --prefer-offline --no-audit
          
          # Production build with optimized memory
          npm run build
          cd ..
          
          echo "‚úÖ Frontend build completed"
        else
          echo "‚è≠Ô∏è Skipping frontend build (no changes detected)"
        fi
        
        # Build and push Docker image with advanced caching
        echo "üö¢ Building Docker image with multi-stage caching..."
        
        # Multi-layer caching strategy
        docker buildx create --use --driver docker-container || true
        docker buildx build \
          --platform linux/amd64 \
          --cache-from type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:cache \
          --cache-to type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:cache,mode=max \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:latest \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:$(git rev-parse --short HEAD) \
          --push \
          --file Dockerfile.prod .
        echo "‚úÖ Docker image built and pushed with optimized caching"

    - name: üß™ Pre-deployment Validation
      env:
        EC2_HOST: ${{ secrets.EC2_PROD_HOST }}
        EC2_USER: ${{ secrets.EC2_USERNAME }}
      run: |
        echo "üîê Setting up secure SSH connection..."
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts
        
        echo "üî¨ Strict pre-deployment validation..."
        ssh -o ConnectTimeout=30 $EC2_USER@$EC2_HOST << VALIDATE_EOF
        set -e
        export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
        cd /opt/restaurant-web
        
        # Check disk space (must have at least 500MB)
        AVAILABLE=\$(/bin/df / | /usr/bin/tail -1 | /usr/bin/awk '{print \$4}')
        if [ "\$AVAILABLE" -lt 512000 ]; then
            echo "‚ùå Insufficient disk space: \${AVAILABLE}KB available"
            exit 1
        fi
        
        # Check if Docker is running
        if ! /usr/bin/docker info > /dev/null 2>&1; then
            echo "‚ùå Docker is not running"
            exit 1
        fi
        
        echo "‚úÖ Pre-deployment validation passed"
        VALIDATE_EOF

    - name: üöÄ Strict EC2 Deployment
      env:
        ACTION: ${{ github.event.inputs.action || 'deploy' }}
        EC2_HOST: ${{ secrets.EC2_PROD_HOST }}
        EC2_USER: ${{ secrets.EC2_USERNAME }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
      run: |        
        echo "üì¶ Uploading deployment scripts..."
        scp -o ConnectTimeout=30 scripts/production-deploy.sh $EC2_USER@$EC2_HOST:/tmp/
        scp -o ConnectTimeout=30 scripts/simple-deploy.sh $EC2_USER@$EC2_HOST:/tmp/
        scp -o ConnectTimeout=30 scripts/auto-cleanup.sh $EC2_USER@$EC2_HOST:/tmp/
        
        echo "üöÄ Executing enterprise-grade deployment on EC2..."
        ssh -o ConnectTimeout=30 -o ServerAliveInterval=60 -o StrictHostKeyChecking=yes $EC2_USER@$EC2_HOST << DEPLOY_EOF
        set -e
        export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
        export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
        export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
        export AWS_DEFAULT_REGION="us-west-2"
        
        cd /opt/restaurant-web
        
        # Copy deployment scripts
        /bin/cp /tmp/production-deploy.sh ./scripts/
        /bin/cp /tmp/simple-deploy.sh ./scripts/
        /bin/cp /tmp/auto-cleanup.sh ./scripts/
        /bin/chmod +x scripts/*.sh
        
        # Execute production deployment with environment variables
        DJANGO_SECRET_KEY='${{ secrets.DJANGO_SECRET_KEY }}' \
        DOMAIN_NAME='${{ secrets.DOMAIN_NAME }}' \
        COGNITO_USER_POOL_ID='${{ secrets.COGNITO_USER_POOL_ID }}' \
        COGNITO_APP_CLIENT_ID='${{ secrets.COGNITO_APP_CLIENT_ID }}' \
        ./scripts/production-deploy.sh "$ECR_REGISTRY" "$ECR_REPOSITORY" "$ACTION"
        DEPLOY_EOF
        
        # Check deployment result
        RESULT=$?
        if [ $RESULT -eq 0 ]; then
          echo "‚úÖ Strict deployment completed successfully"
        else
          echo "‚ùå Strict deployment failed"
          exit 1
        fi

    - name: üè• Post-deployment Validation  
      env:
        EC2_HOST: ${{ secrets.EC2_PROD_HOST }}
        EC2_USER: ${{ secrets.EC2_USERNAME }}
      run: |
        echo "üî¨ Validating production deployment..."
        ssh -o ConnectTimeout=30 $EC2_USER@$EC2_HOST << VALIDATE_EOF
        set -e
        export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
        
        # Test critical API endpoints
        echo "üîç Testing dashboard operativo API..."
        RESPONSE=\$(/usr/bin/curl -s -w "\n%{http_code}" http://localhost/api/v1/dashboard-operativo/report/?date=2025-08-29)
        HTTP_CODE=\$(echo "\$RESPONSE" | tail -n 1)
        if [ "\$HTTP_CODE" != "200" ]; then
            echo "‚ùå Dashboard operativo API failed (HTTP \$HTTP_CODE)"
            exit 1
        fi
        echo "‚úÖ Dashboard operativo API working (HTTP 200)"
        
        echo "üîç Testing dashboard financiero API..."
        RESPONSE=\$(/usr/bin/curl -s -w "\n%{http_code}" "http://localhost/api/v1/dashboard-financiero/report/?date=2025-08-29&period=month")
        HTTP_CODE=\$(echo "\$RESPONSE" | tail -n 1)
        if [ "\$HTTP_CODE" != "200" ]; then
            echo "‚ùå Dashboard financiero API failed (HTTP \$HTTP_CODE)"
            exit 1
        fi
        echo "‚úÖ Dashboard financiero API working (HTTP 200)"
        
        echo "üîç Testing kitchen board API..."  
        RESPONSE=\$(/usr/bin/curl -s -w "\n%{http_code}" http://localhost/api/v1/orders/kitchen_board/)
        HTTP_CODE=\$(echo "\$RESPONSE" | tail -n 1)
        if [ "\$HTTP_CODE" != "200" ]; then
            echo "‚ùå Kitchen board API failed (HTTP \$HTTP_CODE)"
            exit 1
        fi
        echo "‚úÖ Kitchen board API working (HTTP 200)"
        
        # Trigger frontend cache refresh after successful deployment
        echo "üîÑ Triggering frontend cache refresh..."
        /usr/bin/curl -s -X POST http://localhost/api/v1/force-refresh/ || echo "Cache refresh failed (non-critical)"
        
        echo "‚úÖ All critical APIs validated successfully"
        VALIDATE_EOF

    - name: üìä Deployment Summary
      if: always()
      run: |
        echo "## üåü Professional Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Action:** ${{ env.ACTION || 'deploy' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Changes Detected:** ${{ needs.analyze-changes.outputs.changes || 'manual deployment' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
        echo "- **Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "üîó **Live Site:** https://www.xn--elfogndedonsoto-zrb.com/" >> $GITHUB_STEP_SUMMARY